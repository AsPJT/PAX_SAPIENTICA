<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>SFML - Simple and Fast Multimedia Library</title>
        <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
        <link rel="stylesheet" type="text/css" href="doxygen.css" title="default" media="screen,print" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
        <script type="text/javascript" src="clipboard.js"></script>
        <script type="text/javascript" src="cookie.js"></script>
        <link rel="stylesheet" type="text/css" href="search/search.css" />
        <link rel="stylesheet" type="text/css" href="searchOverrides.css" />
        <script type="text/javascript" src="search/searchdata.js"></script>
        <script type="text/javascript" src="search/search.js"></script>
        <script type="text/javascript">
        /* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
          $(document).ready(function() { init_search(); });
        /* @license-end */
        </script>
    </head>
    <body>
        <div id="banner-container">
            <div id="banner">
                <span id="sfml">SFML 3.0.0</span>
            </div>
        </div>
        <div id="content">
            <div>
<!-- Generated by Doxygen 1.13.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="topics.html"><span>Topics</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesf.html">sf</a></li><li class="navelem"><a class="el" href="classsf_1_1VertexBuffer.html">VertexBuffer</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classsf_1_1VertexBuffer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">sf::VertexBuffer Class Reference<div class="ingroups"><a class="el" href="group__graphics.html">Graphics module</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="structsf_1_1Vertex.html" title="Point with color and texture coordinates.">Vertex</a> buffer storage for one or more 2D primitives.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="VertexBuffer_8hpp_source.html">SFML/Graphics/VertexBuffer.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sf::VertexBuffer:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsf_1_1VertexBuffer.png" usemap="#sf::VertexBuffer_map" alt=""/>
  <map id="sf::VertexBuffer_map" name="sf::VertexBuffer_map">
<area href="classsf_1_1Drawable.html" title="Abstract base class for objects that can be drawn to a render target." alt="sf::Drawable" shape="rect" coords="0,0,100,24"/>
<area href="classsf_1_1GlResource.html" title="Base class for classes that require an OpenGL context." alt="sf::GlResource" shape="rect" coords="110,0,210,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3a531528684e63ecb45edd51282f5cb7" id="r_a3a531528684e63ecb45edd51282f5cb7"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a531528684e63ecb45edd51282f5cb7">Usage</a> { <a class="el" href="#a3a531528684e63ecb45edd51282f5cb7aeae835e83c0494a376229f254f7d3392">Stream</a>
, <a class="el" href="#a3a531528684e63ecb45edd51282f5cb7a971fd8cc345d8bd9f92e9f7d88fdf20c">Dynamic</a>
, <a class="el" href="#a3a531528684e63ecb45edd51282f5cb7a84a8921b25f505d0d2077aeb5db4bc16">Static</a>
 }</td></tr>
<tr class="memdesc:a3a531528684e63ecb45edd51282f5cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#a3a531528684e63ecb45edd51282f5cb7" title="Usage specifiers.">Usage</a> specifiers.  <a href="#a3a531528684e63ecb45edd51282f5cb7">More...</a><br /></td></tr>
<tr class="separator:a3a531528684e63ecb45edd51282f5cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9824d6fc4d01bc542082ff4436885399" id="r_a9824d6fc4d01bc542082ff4436885399"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9824d6fc4d01bc542082ff4436885399">VertexBuffer</a> ()=default</td></tr>
<tr class="memdesc:a9824d6fc4d01bc542082ff4436885399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:a9824d6fc4d01bc542082ff4436885399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f51dcd61dac52be54ba7b22ebdea7c8" id="r_a3f51dcd61dac52be54ba7b22ebdea7c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f51dcd61dac52be54ba7b22ebdea7c8">VertexBuffer</a> (<a class="el" href="group__graphics.html#ga5ee56ac1339984909610713096283b1b">PrimitiveType</a> type)</td></tr>
<tr class="memdesc:a3f51dcd61dac52be54ba7b22ebdea7c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <code><a class="el" href="classsf_1_1VertexBuffer.html" title="Vertex buffer storage for one or more 2D primitives.">VertexBuffer</a></code> with a specific <code><a class="el" href="group__graphics.html#ga5ee56ac1339984909610713096283b1b" title="Types of primitives that a sf::VertexArray can render.">PrimitiveType</a></code>  <br /></td></tr>
<tr class="separator:a3f51dcd61dac52be54ba7b22ebdea7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2dce0a43e061e5f91b97cf7267427e3" id="r_af2dce0a43e061e5f91b97cf7267427e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2dce0a43e061e5f91b97cf7267427e3">VertexBuffer</a> (<a class="el" href="#a3a531528684e63ecb45edd51282f5cb7">Usage</a> usage)</td></tr>
<tr class="memdesc:af2dce0a43e061e5f91b97cf7267427e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <code><a class="el" href="classsf_1_1VertexBuffer.html" title="Vertex buffer storage for one or more 2D primitives.">VertexBuffer</a></code> with a specific usage specifier.  <br /></td></tr>
<tr class="separator:af2dce0a43e061e5f91b97cf7267427e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326a5c89f1ba01b51b323535494434e8" id="r_a326a5c89f1ba01b51b323535494434e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a326a5c89f1ba01b51b323535494434e8">VertexBuffer</a> (<a class="el" href="group__graphics.html#ga5ee56ac1339984909610713096283b1b">PrimitiveType</a> type, <a class="el" href="#a3a531528684e63ecb45edd51282f5cb7">Usage</a> usage)</td></tr>
<tr class="memdesc:a326a5c89f1ba01b51b323535494434e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <code><a class="el" href="classsf_1_1VertexBuffer.html" title="Vertex buffer storage for one or more 2D primitives.">VertexBuffer</a></code> with a specific <code><a class="el" href="group__graphics.html#ga5ee56ac1339984909610713096283b1b" title="Types of primitives that a sf::VertexArray can render.">PrimitiveType</a></code> and usage specifier.  <br /></td></tr>
<tr class="separator:a326a5c89f1ba01b51b323535494434e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2ff1e218cfc749b87f8873e23c016b" id="r_a2f2ff1e218cfc749b87f8873e23c016b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f2ff1e218cfc749b87f8873e23c016b">VertexBuffer</a> (const <a class="el" href="classsf_1_1VertexBuffer.html">VertexBuffer</a> &amp;copy)</td></tr>
<tr class="memdesc:a2f2ff1e218cfc749b87f8873e23c016b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a2f2ff1e218cfc749b87f8873e23c016b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ecc5d81030a0da11e3faede81fd9b11" id="r_a1ecc5d81030a0da11e3faede81fd9b11"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ecc5d81030a0da11e3faede81fd9b11">~VertexBuffer</a> () override</td></tr>
<tr class="memdesc:a1ecc5d81030a0da11e3faede81fd9b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a1ecc5d81030a0da11e3faede81fd9b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68e128d59c7f7d5eb0d4d94125439a5" id="r_aa68e128d59c7f7d5eb0d4d94125439a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa68e128d59c7f7d5eb0d4d94125439a5">create</a> (std::size_t vertexCount)</td></tr>
<tr class="memdesc:aa68e128d59c7f7d5eb0d4d94125439a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the vertex buffer.  <br /></td></tr>
<tr class="separator:aa68e128d59c7f7d5eb0d4d94125439a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c534536ed186a2ad65e75484c8abafe" id="r_a6c534536ed186a2ad65e75484c8abafe"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c534536ed186a2ad65e75484c8abafe">getVertexCount</a> () const</td></tr>
<tr class="memdesc:a6c534536ed186a2ad65e75484c8abafe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vertex count.  <br /></td></tr>
<tr class="separator:a6c534536ed186a2ad65e75484c8abafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad100a5f578a91c49a9009e3c6956c82d" id="r_ad100a5f578a91c49a9009e3c6956c82d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad100a5f578a91c49a9009e3c6956c82d">update</a> (const <a class="el" href="structsf_1_1Vertex.html">Vertex</a> *vertices)</td></tr>
<tr class="memdesc:ad100a5f578a91c49a9009e3c6956c82d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the whole buffer from an array of vertices.  <br /></td></tr>
<tr class="separator:ad100a5f578a91c49a9009e3c6956c82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c8649a64861507010d21e77fbd53fa" id="r_ae6c8649a64861507010d21e77fbd53fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6c8649a64861507010d21e77fbd53fa">update</a> (const <a class="el" href="structsf_1_1Vertex.html">Vertex</a> *vertices, std::size_t vertexCount, unsigned int offset)</td></tr>
<tr class="memdesc:ae6c8649a64861507010d21e77fbd53fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a part of the buffer from an array of vertices.  <br /></td></tr>
<tr class="separator:ae6c8649a64861507010d21e77fbd53fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f8bbcf07f403e7fe29b1b905dc7544" id="r_a41f8bbcf07f403e7fe29b1b905dc7544"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41f8bbcf07f403e7fe29b1b905dc7544">update</a> (const <a class="el" href="classsf_1_1VertexBuffer.html">VertexBuffer</a> &amp;vertexBuffer)</td></tr>
<tr class="memdesc:a41f8bbcf07f403e7fe29b1b905dc7544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of another buffer into this buffer.  <br /></td></tr>
<tr class="separator:a41f8bbcf07f403e7fe29b1b905dc7544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d19f938e30e1bb1788067e3c134653" id="r_ae9d19f938e30e1bb1788067e3c134653"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsf_1_1VertexBuffer.html">VertexBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9d19f938e30e1bb1788067e3c134653">operator=</a> (const <a class="el" href="classsf_1_1VertexBuffer.html">VertexBuffer</a> &amp;right)</td></tr>
<tr class="memdesc:ae9d19f938e30e1bb1788067e3c134653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of assignment operator.  <br /></td></tr>
<tr class="separator:ae9d19f938e30e1bb1788067e3c134653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0c81c4a48b250b36813d0f452b3c68" id="r_afe0c81c4a48b250b36813d0f452b3c68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe0c81c4a48b250b36813d0f452b3c68">swap</a> (<a class="el" href="classsf_1_1VertexBuffer.html">VertexBuffer</a> &amp;right) noexcept</td></tr>
<tr class="memdesc:afe0c81c4a48b250b36813d0f452b3c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the contents of this vertex buffer with those of another.  <br /></td></tr>
<tr class="separator:afe0c81c4a48b250b36813d0f452b3c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343fa0a240c91bc4203a6727fcd9b920" id="r_a343fa0a240c91bc4203a6727fcd9b920"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a343fa0a240c91bc4203a6727fcd9b920">getNativeHandle</a> () const</td></tr>
<tr class="memdesc:a343fa0a240c91bc4203a6727fcd9b920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying OpenGL handle of the vertex buffer.  <br /></td></tr>
<tr class="separator:a343fa0a240c91bc4203a6727fcd9b920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c429dbef94224a86d605cf4c68aa02d" id="r_a7c429dbef94224a86d605cf4c68aa02d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c429dbef94224a86d605cf4c68aa02d">setPrimitiveType</a> (<a class="el" href="group__graphics.html#ga5ee56ac1339984909610713096283b1b">PrimitiveType</a> type)</td></tr>
<tr class="memdesc:a7c429dbef94224a86d605cf4c68aa02d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the type of primitives to draw.  <br /></td></tr>
<tr class="separator:a7c429dbef94224a86d605cf4c68aa02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02061d85472ff69e7ad14dc72f8fcaa4" id="r_a02061d85472ff69e7ad14dc72f8fcaa4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__graphics.html#ga5ee56ac1339984909610713096283b1b">PrimitiveType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02061d85472ff69e7ad14dc72f8fcaa4">getPrimitiveType</a> () const</td></tr>
<tr class="memdesc:a02061d85472ff69e7ad14dc72f8fcaa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of primitives drawn by the vertex buffer.  <br /></td></tr>
<tr class="separator:a02061d85472ff69e7ad14dc72f8fcaa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace40070db1fccf12a025383b23e81cad" id="r_ace40070db1fccf12a025383b23e81cad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace40070db1fccf12a025383b23e81cad">setUsage</a> (<a class="el" href="#a3a531528684e63ecb45edd51282f5cb7">Usage</a> usage)</td></tr>
<tr class="memdesc:ace40070db1fccf12a025383b23e81cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the usage specifier of this vertex buffer.  <br /></td></tr>
<tr class="separator:ace40070db1fccf12a025383b23e81cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e36f2b3955bb35648c17550a9c096e1" id="r_a5e36f2b3955bb35648c17550a9c096e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3a531528684e63ecb45edd51282f5cb7">Usage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e36f2b3955bb35648c17550a9c096e1">getUsage</a> () const</td></tr>
<tr class="memdesc:a5e36f2b3955bb35648c17550a9c096e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the usage specifier of this vertex buffer.  <br /></td></tr>
<tr class="separator:a5e36f2b3955bb35648c17550a9c096e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1c623e9701b43125e4b3661bc0d0b65b" id="r_a1c623e9701b43125e4b3661bc0d0b65b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c623e9701b43125e4b3661bc0d0b65b">bind</a> (const <a class="el" href="classsf_1_1VertexBuffer.html">VertexBuffer</a> *vertexBuffer)</td></tr>
<tr class="memdesc:a1c623e9701b43125e4b3661bc0d0b65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a vertex buffer for rendering.  <br /></td></tr>
<tr class="separator:a1c623e9701b43125e4b3661bc0d0b65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6304bc4134dc0164dc94eff887b08847" id="r_a6304bc4134dc0164dc94eff887b08847"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6304bc4134dc0164dc94eff887b08847">isAvailable</a> ()</td></tr>
<tr class="memdesc:a6304bc4134dc0164dc94eff887b08847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell whether or not the system supports vertex buffers.  <br /></td></tr>
<tr class="separator:a6304bc4134dc0164dc94eff887b08847"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="structsf_1_1Vertex.html" title="Point with color and texture coordinates.">Vertex</a> buffer storage for one or more 2D primitives. </p>
<p><code><a class="el" href="classsf_1_1VertexBuffer.html" title="Vertex buffer storage for one or more 2D primitives.">sf::VertexBuffer</a></code> is a simple wrapper around a dynamic buffer of vertices and a primitives type.</p>
<p>Unlike <code><a class="el" href="classsf_1_1VertexArray.html" title="Set of one or more 2D primitives.">sf::VertexArray</a></code>, the vertex data is stored in graphics memory.</p>
<p>In situations where a large amount of vertex data would have to be transferred from system memory to graphics memory every frame, using <code><a class="el" href="classsf_1_1VertexBuffer.html" title="Vertex buffer storage for one or more 2D primitives.">sf::VertexBuffer</a></code> can help. By using a <code><a class="el" href="classsf_1_1VertexBuffer.html" title="Vertex buffer storage for one or more 2D primitives.">sf::VertexBuffer</a></code>, data that has not been changed between frames does not have to be re-transferred from system to graphics memory as would be the case with <code><a class="el" href="classsf_1_1VertexArray.html" title="Set of one or more 2D primitives.">sf::VertexArray</a></code>. If data transfer is a bottleneck, this can lead to performance gains.</p>
<p>Using <code><a class="el" href="classsf_1_1VertexBuffer.html" title="Vertex buffer storage for one or more 2D primitives.">sf::VertexBuffer</a></code>, the user also has the ability to only modify a portion of the buffer in graphics memory. This way, a large buffer can be allocated at the start of the application and only the applicable portions of it need to be updated during the course of the application. This allows the user to take full control of data transfers between system and graphics memory if they need to.</p>
<p>In special cases, the user can make use of multiple threads to update vertex data in multiple distinct regions of the buffer simultaneously. This might make sense when e.g. the position of multiple objects has to be recalculated very frequently. The computation load can be spread across multiple threads as long as there are no other data dependencies.</p>
<p>Simultaneous updates to the vertex buffer are not guaranteed to be carried out by the driver in any specific order. Updating the same region of the buffer from multiple threads will not cause undefined behavior, however the final state of the buffer will be unpredictable.</p>
<p>Simultaneous updates of distinct non-overlapping regions of the buffer are also not guaranteed to complete in a specific order. However, in this case the user can make sure to synchronize the writer threads at well-defined points in their code. The driver will make sure that all pending data transfers complete before the vertex buffer is sourced by the rendering pipeline.</p>
<p>It inherits <code><a class="el" href="classsf_1_1Drawable.html" title="Abstract base class for objects that can be drawn to a render target.">sf::Drawable</a></code>, but unlike other drawables it is not transformable.</p>
<p>Example: </p><div class="fragment"><div class="line">std::array&lt;sf::Vertex, 15&gt; vertices;</div>
<div class="line">...</div>
<div class="line">sf::VertexBuffer triangles(<a class="code hl_enumvalue" href="group__graphics.html#gga5ee56ac1339984909610713096283b1ba7ca66fdfaad3eb33fc65d7490178f856">sf::PrimitiveType::Triangles</a>);</div>
<div class="line">triangles.create(vertices.size());</div>
<div class="line">triangles.update(vertices.data());</div>
<div class="line">...</div>
<div class="line">window.draw(triangles);</div>
<div class="ttc" id="agroup__graphics_html_gga5ee56ac1339984909610713096283b1ba7ca66fdfaad3eb33fc65d7490178f856"><div class="ttname"><a href="group__graphics.html#gga5ee56ac1339984909610713096283b1ba7ca66fdfaad3eb33fc65d7490178f856">sf::PrimitiveType::Triangles</a></div><div class="ttdeci">@ Triangles</div><div class="ttdoc">List of individual triangles.</div><div class="ttdef"><b>Definition</b> <a href="PrimitiveType_8hpp_source.html#l00043">PrimitiveType.hpp:43</a></div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsf_1_1Vertex.html" title="Point with color and texture coordinates.">sf::Vertex</a></code>, <code><a class="el" href="classsf_1_1VertexArray.html" title="Set of one or more 2D primitives.">sf::VertexArray</a></code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="VertexBuffer_8hpp_source.html#l00050">50</a> of file <a class="el" href="VertexBuffer_8hpp_source.html">VertexBuffer.hpp</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a3a531528684e63ecb45edd51282f5cb7" name="a3a531528684e63ecb45edd51282f5cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a531528684e63ecb45edd51282f5cb7">&#9670;&#160;</a></span>Usage</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a3a531528684e63ecb45edd51282f5cb7">sf::VertexBuffer::Usage</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="#a3a531528684e63ecb45edd51282f5cb7" title="Usage specifiers.">Usage</a> specifiers. </p>
<p>If data is going to be updated once or more every frame, set the usage to Stream. If data is going to be set once and used for a long time without being modified, set the usage to Static. For everything else Dynamic should be a good compromise. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3a531528684e63ecb45edd51282f5cb7aeae835e83c0494a376229f254f7d3392" name="a3a531528684e63ecb45edd51282f5cb7aeae835e83c0494a376229f254f7d3392"></a>Stream&#160;</td><td class="fielddoc"><p>Constantly changing data. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3a531528684e63ecb45edd51282f5cb7a971fd8cc345d8bd9f92e9f7d88fdf20c" name="a3a531528684e63ecb45edd51282f5cb7a971fd8cc345d8bd9f92e9f7d88fdf20c"></a>Dynamic&#160;</td><td class="fielddoc"><p>Occasionally changing data. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3a531528684e63ecb45edd51282f5cb7a84a8921b25f505d0d2077aeb5db4bc16" name="a3a531528684e63ecb45edd51282f5cb7a84a8921b25f505d0d2077aeb5db4bc16"></a>Static&#160;</td><td class="fielddoc"><p>Rarely changing data. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="VertexBuffer_8hpp_source.html#l00063">63</a> of file <a class="el" href="VertexBuffer_8hpp_source.html">VertexBuffer.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9824d6fc4d01bc542082ff4436885399" name="a9824d6fc4d01bc542082ff4436885399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9824d6fc4d01bc542082ff4436885399">&#9670;&#160;</a></span>VertexBuffer() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sf::VertexBuffer::VertexBuffer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Creates an empty vertex buffer. </p>

</div>
</div>
<a id="a3f51dcd61dac52be54ba7b22ebdea7c8" name="a3f51dcd61dac52be54ba7b22ebdea7c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f51dcd61dac52be54ba7b22ebdea7c8">&#9670;&#160;</a></span>VertexBuffer() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sf::VertexBuffer::VertexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__graphics.html#ga5ee56ac1339984909610713096283b1b">PrimitiveType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <code><a class="el" href="classsf_1_1VertexBuffer.html" title="Vertex buffer storage for one or more 2D primitives.">VertexBuffer</a></code> with a specific <code><a class="el" href="group__graphics.html#ga5ee56ac1339984909610713096283b1b" title="Types of primitives that a sf::VertexArray can render.">PrimitiveType</a></code> </p>
<p>Creates an empty vertex buffer and sets its primitive type to <code class="param">type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Type of primitive </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2dce0a43e061e5f91b97cf7267427e3" name="af2dce0a43e061e5f91b97cf7267427e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2dce0a43e061e5f91b97cf7267427e3">&#9670;&#160;</a></span>VertexBuffer() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sf::VertexBuffer::VertexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a3a531528684e63ecb45edd51282f5cb7">Usage</a></td>          <td class="paramname"><span class="paramname"><em>usage</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <code><a class="el" href="classsf_1_1VertexBuffer.html" title="Vertex buffer storage for one or more 2D primitives.">VertexBuffer</a></code> with a specific usage specifier. </p>
<p>Creates an empty vertex buffer and sets its usage to <code class="param">usage</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">usage</td><td><a class="el" href="#a3a531528684e63ecb45edd51282f5cb7" title="Usage specifiers.">Usage</a> specifier </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a326a5c89f1ba01b51b323535494434e8" name="a326a5c89f1ba01b51b323535494434e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a326a5c89f1ba01b51b323535494434e8">&#9670;&#160;</a></span>VertexBuffer() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sf::VertexBuffer::VertexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__graphics.html#ga5ee56ac1339984909610713096283b1b">PrimitiveType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a3a531528684e63ecb45edd51282f5cb7">Usage</a></td>          <td class="paramname"><span class="paramname"><em>usage</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <code><a class="el" href="classsf_1_1VertexBuffer.html" title="Vertex buffer storage for one or more 2D primitives.">VertexBuffer</a></code> with a specific <code><a class="el" href="group__graphics.html#ga5ee56ac1339984909610713096283b1b" title="Types of primitives that a sf::VertexArray can render.">PrimitiveType</a></code> and usage specifier. </p>
<p>Creates an empty vertex buffer and sets its primitive type to <code class="param">type</code> and usage to <code class="param">usage</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Type of primitive </td></tr>
    <tr><td class="paramname">usage</td><td><a class="el" href="#a3a531528684e63ecb45edd51282f5cb7" title="Usage specifiers.">Usage</a> specifier </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f2ff1e218cfc749b87f8873e23c016b" name="a2f2ff1e218cfc749b87f8873e23c016b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f2ff1e218cfc749b87f8873e23c016b">&#9670;&#160;</a></span>VertexBuffer() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sf::VertexBuffer::VertexBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1VertexBuffer.html">VertexBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>copy</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>instance to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ecc5d81030a0da11e3faede81fd9b11" name="a1ecc5d81030a0da11e3faede81fd9b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ecc5d81030a0da11e3faede81fd9b11">&#9670;&#160;</a></span>~VertexBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sf::VertexBuffer::~VertexBuffer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1c623e9701b43125e4b3661bc0d0b65b" name="a1c623e9701b43125e4b3661bc0d0b65b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c623e9701b43125e4b3661bc0d0b65b">&#9670;&#160;</a></span>bind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sf::VertexBuffer::bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1VertexBuffer.html">VertexBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>vertexBuffer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a vertex buffer for rendering. </p>
<p>This function is not part of the graphics API, it mustn't be used when drawing SFML entities. It must be used only if you mix <code><a class="el" href="classsf_1_1VertexBuffer.html" title="Vertex buffer storage for one or more 2D primitives.">sf::VertexBuffer</a></code> with OpenGL code.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsf_1_1VertexBuffer.html">sf::VertexBuffer</a> vb1, vb2;</div>
<div class="line">...</div>
<div class="line">sf::VertexBuffer::bind(&amp;vb1);</div>
<div class="line"><span class="comment">// draw OpenGL stuff that use vb1...</span></div>
<div class="line"><a class="code hl_function" href="#a1c623e9701b43125e4b3661bc0d0b65b">sf::VertexBuffer::bind</a>(&amp;vb2);</div>
<div class="line"><span class="comment">// draw OpenGL stuff that use vb2...</span></div>
<div class="line"><a class="code hl_function" href="#a1c623e9701b43125e4b3661bc0d0b65b">sf::VertexBuffer::bind</a>(<span class="keyword">nullptr</span>);</div>
<div class="line"><span class="comment">// draw OpenGL stuff that use no vertex buffer...</span></div>
<div class="ttc" id="aclasssf_1_1VertexBuffer_html"><div class="ttname"><a href="classsf_1_1VertexBuffer.html">sf::VertexBuffer</a></div><div class="ttdoc">Vertex buffer storage for one or more 2D primitives.</div><div class="ttdef"><b>Definition</b> <a href="VertexBuffer_8hpp_source.html#l00050">VertexBuffer.hpp:51</a></div></div>
<div class="ttc" id="aclasssf_1_1VertexBuffer_html_a1c623e9701b43125e4b3661bc0d0b65b"><div class="ttname"><a href="#a1c623e9701b43125e4b3661bc0d0b65b">sf::VertexBuffer::bind</a></div><div class="ttdeci">static void bind(const VertexBuffer *vertexBuffer)</div><div class="ttdoc">Bind a vertex buffer for rendering.</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexBuffer</td><td>Pointer to the vertex buffer to bind, can be null to use no vertex buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa68e128d59c7f7d5eb0d4d94125439a5" name="aa68e128d59c7f7d5eb0d4d94125439a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa68e128d59c7f7d5eb0d4d94125439a5">&#9670;&#160;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sf::VertexBuffer::create </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>vertexCount</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the vertex buffer. </p>
<p>Creates the vertex buffer and allocates enough graphics memory to hold <code>vertexCount</code> vertices. Any previously allocated memory is freed in the process.</p>
<p>In order to deallocate previously allocated memory pass 0 as <code>vertexCount</code>. Don't forget to recreate with a non-zero value when graphics memory should be allocated again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexCount</td><td>Number of vertices worth of memory to allocate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if creation was successful </dd></dl>

</div>
</div>
<a id="a343fa0a240c91bc4203a6727fcd9b920" name="a343fa0a240c91bc4203a6727fcd9b920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a343fa0a240c91bc4203a6727fcd9b920">&#9670;&#160;</a></span>getNativeHandle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int sf::VertexBuffer::getNativeHandle </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the underlying OpenGL handle of the vertex buffer. </p>
<p>You shouldn't need to use this function, unless you have very specific stuff to implement that SFML doesn't support, or implement a temporary workaround until a bug is fixed.</p>
<dl class="section return"><dt>Returns</dt><dd>OpenGL handle of the vertex buffer or 0 if not yet created </dd></dl>

</div>
</div>
<a id="a02061d85472ff69e7ad14dc72f8fcaa4" name="a02061d85472ff69e7ad14dc72f8fcaa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02061d85472ff69e7ad14dc72f8fcaa4">&#9670;&#160;</a></span>getPrimitiveType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__graphics.html#ga5ee56ac1339984909610713096283b1b">PrimitiveType</a> sf::VertexBuffer::getPrimitiveType </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the type of primitives drawn by the vertex buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Primitive type </dd></dl>

</div>
</div>
<a id="a5e36f2b3955bb35648c17550a9c096e1" name="a5e36f2b3955bb35648c17550a9c096e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e36f2b3955bb35648c17550a9c096e1">&#9670;&#160;</a></span>getUsage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3a531528684e63ecb45edd51282f5cb7">Usage</a> sf::VertexBuffer::getUsage </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the usage specifier of this vertex buffer. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="#a3a531528684e63ecb45edd51282f5cb7" title="Usage specifiers.">Usage</a> specifier </dd></dl>

</div>
</div>
<a id="a6c534536ed186a2ad65e75484c8abafe" name="a6c534536ed186a2ad65e75484c8abafe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c534536ed186a2ad65e75484c8abafe">&#9670;&#160;</a></span>getVertexCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t sf::VertexBuffer::getVertexCount </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the vertex count. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of vertices in the vertex buffer </dd></dl>

</div>
</div>
<a id="a6304bc4134dc0164dc94eff887b08847" name="a6304bc4134dc0164dc94eff887b08847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6304bc4134dc0164dc94eff887b08847">&#9670;&#160;</a></span>isAvailable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool sf::VertexBuffer::isAvailable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell whether or not the system supports vertex buffers. </p>
<p>This function should always be called before using the vertex buffer features. If it returns <code>false</code>, then any attempt to use <code><a class="el" href="classsf_1_1VertexBuffer.html" title="Vertex buffer storage for one or more 2D primitives.">sf::VertexBuffer</a></code> will fail.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if vertex buffers are supported, <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="ae9d19f938e30e1bb1788067e3c134653" name="ae9d19f938e30e1bb1788067e3c134653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d19f938e30e1bb1788067e3c134653">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1VertexBuffer.html">VertexBuffer</a> &amp; sf::VertexBuffer::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1VertexBuffer.html">VertexBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>right</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>Instance to assign</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to self </dd></dl>

</div>
</div>
<a id="a7c429dbef94224a86d605cf4c68aa02d" name="a7c429dbef94224a86d605cf4c68aa02d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c429dbef94224a86d605cf4c68aa02d">&#9670;&#160;</a></span>setPrimitiveType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::VertexBuffer::setPrimitiveType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__graphics.html#ga5ee56ac1339984909610713096283b1b">PrimitiveType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the type of primitives to draw. </p>
<p>This function defines how the vertices must be interpreted when it's time to draw them.</p>
<p>The default primitive type is <code><a class="el" href="group__graphics.html#gga5ee56ac1339984909610713096283b1ba75dd5f1160a3f02b6fae89c54361a1b3" title="List of individual points.">sf::PrimitiveType::Points</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Type of primitive </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace40070db1fccf12a025383b23e81cad" name="ace40070db1fccf12a025383b23e81cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace40070db1fccf12a025383b23e81cad">&#9670;&#160;</a></span>setUsage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::VertexBuffer::setUsage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a3a531528684e63ecb45edd51282f5cb7">Usage</a></td>          <td class="paramname"><span class="paramname"><em>usage</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the usage specifier of this vertex buffer. </p>
<p>This function provides a hint about how this vertex buffer is going to be used in terms of data update frequency.</p>
<p>After changing the usage specifier, the vertex buffer has to be updated with new data for the usage specifier to take effect.</p>
<p>The default usage type is <code><a class="el" href="#a3a531528684e63ecb45edd51282f5cb7aeae835e83c0494a376229f254f7d3392" title="Constantly changing data.">sf::VertexBuffer::Usage::Stream</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">usage</td><td><a class="el" href="#a3a531528684e63ecb45edd51282f5cb7" title="Usage specifiers.">Usage</a> specifier </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe0c81c4a48b250b36813d0f452b3c68" name="afe0c81c4a48b250b36813d0f452b3c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe0c81c4a48b250b36813d0f452b3c68">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::VertexBuffer::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1VertexBuffer.html">VertexBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>right</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the contents of this vertex buffer with those of another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>Instance to swap with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad100a5f578a91c49a9009e3c6956c82d" name="ad100a5f578a91c49a9009e3c6956c82d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad100a5f578a91c49a9009e3c6956c82d">&#9670;&#160;</a></span>update() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sf::VertexBuffer::update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsf_1_1Vertex.html">Vertex</a> *</td>          <td class="paramname"><span class="paramname"><em>vertices</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the whole buffer from an array of vertices. </p>
<p>The vertex array is assumed to have the same size as the created buffer.</p>
<p>No additional check is performed on the size of the vertex array. Passing invalid arguments will lead to undefined behavior.</p>
<p>This function does nothing if <code>vertices</code> is null or if the buffer was not previously created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Array of vertices to copy to the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the update was successful </dd></dl>

</div>
</div>
<a id="ae6c8649a64861507010d21e77fbd53fa" name="ae6c8649a64861507010d21e77fbd53fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6c8649a64861507010d21e77fbd53fa">&#9670;&#160;</a></span>update() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sf::VertexBuffer::update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsf_1_1Vertex.html">Vertex</a> *</td>          <td class="paramname"><span class="paramname"><em>vertices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>vertexCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update a part of the buffer from an array of vertices. </p>
<p><code>offset</code> is specified as the number of vertices to skip from the beginning of the buffer.</p>
<p>If <code>offset</code> is 0 and <code>vertexCount</code> is equal to the size of the currently created buffer, its whole contents are replaced.</p>
<p>If <code>offset</code> is 0 and <code>vertexCount</code> is greater than the size of the currently created buffer, a new buffer is created containing the vertex data.</p>
<p>If <code>offset</code> is 0 and <code>vertexCount</code> is less than the size of the currently created buffer, only the corresponding region is updated.</p>
<p>If <code>offset</code> is not 0 and <code>offset</code> + <code>vertexCount</code> is greater than the size of the currently created buffer, the update fails.</p>
<p>No additional check is performed on the size of the vertex array. Passing invalid arguments will lead to undefined behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Array of vertices to copy to the buffer </td></tr>
    <tr><td class="paramname">vertexCount</td><td>Number of vertices to copy </td></tr>
    <tr><td class="paramname">offset</td><td>Offset in the buffer to copy to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the update was successful </dd></dl>

</div>
</div>
<a id="a41f8bbcf07f403e7fe29b1b905dc7544" name="a41f8bbcf07f403e7fe29b1b905dc7544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f8bbcf07f403e7fe29b1b905dc7544">&#9670;&#160;</a></span>update() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sf::VertexBuffer::update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1VertexBuffer.html">VertexBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vertexBuffer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the contents of another buffer into this buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexBuffer</td><td><a class="el" href="structsf_1_1Vertex.html" title="Point with color and texture coordinates.">Vertex</a> buffer whose contents to copy into this vertex buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the copy was successful </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="VertexBuffer_8hpp_source.html">VertexBuffer.hpp</a></li>
</ul>
</div><!-- contents -->
        </div>
        <div id="footer-container">
            <div id="footer">
                SFML is licensed under the terms and conditions of the <a href="https://www.sfml-dev.org/license.php">zlib/png license</a>.<br />
                Copyright &copy; Laurent Gomila &nbsp;::&nbsp;
                Documentation generated by <a href="http://www.doxygen.org/" title="doxygen website">doxygen</a> &nbsp;::&nbsp;
            </div>
        </div>
    </body>
</html>
