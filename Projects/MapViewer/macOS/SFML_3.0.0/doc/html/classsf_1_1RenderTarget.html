<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>SFML - Simple and Fast Multimedia Library</title>
        <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
        <link rel="stylesheet" type="text/css" href="doxygen.css" title="default" media="screen,print" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
        <script type="text/javascript" src="clipboard.js"></script>
        <script type="text/javascript" src="cookie.js"></script>
        <link rel="stylesheet" type="text/css" href="search/search.css" />
        <link rel="stylesheet" type="text/css" href="searchOverrides.css" />
        <script type="text/javascript" src="search/searchdata.js"></script>
        <script type="text/javascript" src="search/search.js"></script>
        <script type="text/javascript">
        /* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
          $(document).ready(function() { init_search(); });
        /* @license-end */
        </script>
    </head>
    <body>
        <div id="banner-container">
            <div id="banner">
                <span id="sfml">SFML 3.0.0</span>
            </div>
        </div>
        <div id="content">
            <div>
<!-- Generated by Doxygen 1.13.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="topics.html"><span>Topics</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesf.html">sf</a></li><li class="navelem"><a class="el" href="classsf_1_1RenderTarget.html">RenderTarget</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classsf_1_1RenderTarget-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">sf::RenderTarget Class Reference<span class="mlabels"><span class="mlabel abstract">abstract</span></span><div class="ingroups"><a class="el" href="group__graphics.html">Graphics module</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Base class for all render targets (window, texture, ...)  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="RenderTarget_8hpp_source.html">SFML/Graphics/RenderTarget.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sf::RenderTarget:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsf_1_1RenderTarget.png" usemap="#sf::RenderTarget_map" alt=""/>
  <map id="sf::RenderTarget_map" name="sf::RenderTarget_map">
<area href="classsf_1_1RenderTexture.html" title="Target for off-screen 2D rendering into a texture." alt="sf::RenderTexture" shape="rect" coords="0,56,113,80"/>
<area href="classsf_1_1RenderWindow.html" title="Window that can serve as a target for 2D drawing." alt="sf::RenderWindow" shape="rect" coords="123,56,236,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab7da7ccb48bd3983b33fe359258ca71d" id="r_ab7da7ccb48bd3983b33fe359258ca71d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7da7ccb48bd3983b33fe359258ca71d">~RenderTarget</a> ()=default</td></tr>
<tr class="memdesc:ab7da7ccb48bd3983b33fe359258ca71d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:ab7da7ccb48bd3983b33fe359258ca71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec429e06ee84e7fbeaf00632afde191c" id="r_aec429e06ee84e7fbeaf00632afde191c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec429e06ee84e7fbeaf00632afde191c">RenderTarget</a> (const <a class="el" href="classsf_1_1RenderTarget.html">RenderTarget</a> &amp;)=delete</td></tr>
<tr class="memdesc:aec429e06ee84e7fbeaf00632afde191c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy constructor.  <br /></td></tr>
<tr class="separator:aec429e06ee84e7fbeaf00632afde191c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18bb39bb3a26766582fad362516ac2e" id="r_ab18bb39bb3a26766582fad362516ac2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsf_1_1RenderTarget.html">RenderTarget</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab18bb39bb3a26766582fad362516ac2e">operator=</a> (const <a class="el" href="classsf_1_1RenderTarget.html">RenderTarget</a> &amp;)=delete</td></tr>
<tr class="memdesc:ab18bb39bb3a26766582fad362516ac2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy assignment.  <br /></td></tr>
<tr class="separator:ab18bb39bb3a26766582fad362516ac2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa076083f766b1b57d30ceb61cf216dff" id="r_aa076083f766b1b57d30ceb61cf216dff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa076083f766b1b57d30ceb61cf216dff">RenderTarget</a> (<a class="el" href="classsf_1_1RenderTarget.html">RenderTarget</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:aa076083f766b1b57d30ceb61cf216dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="separator:aa076083f766b1b57d30ceb61cf216dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94e144a10d39e6f84d50bea6e18cb10" id="r_ae94e144a10d39e6f84d50bea6e18cb10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsf_1_1RenderTarget.html">RenderTarget</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae94e144a10d39e6f84d50bea6e18cb10">operator=</a> (<a class="el" href="classsf_1_1RenderTarget.html">RenderTarget</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:ae94e144a10d39e6f84d50bea6e18cb10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment.  <br /></td></tr>
<tr class="separator:ae94e144a10d39e6f84d50bea6e18cb10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee353fc2cd35edf0747e710301af3e4c" id="r_aee353fc2cd35edf0747e710301af3e4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee353fc2cd35edf0747e710301af3e4c">clear</a> (<a class="el" href="classsf_1_1Color.html">Color</a> color=<a class="el" href="classsf_1_1Color.html#a77c688197b981338f0b19dc58bd2facd">Color::Black</a>)</td></tr>
<tr class="memdesc:aee353fc2cd35edf0747e710301af3e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the entire target with a single color.  <br /></td></tr>
<tr class="separator:aee353fc2cd35edf0747e710301af3e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5756ecc36a0ad169809063f8f2563cbe" id="r_a5756ecc36a0ad169809063f8f2563cbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5756ecc36a0ad169809063f8f2563cbe">clearStencil</a> (<a class="el" href="structsf_1_1StencilValue.html">StencilValue</a> stencilValue)</td></tr>
<tr class="memdesc:a5756ecc36a0ad169809063f8f2563cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the stencil buffer to a specific value.  <br /></td></tr>
<tr class="separator:a5756ecc36a0ad169809063f8f2563cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4dd9e35771ba842f0feb4ba52cebb9" id="r_a6b4dd9e35771ba842f0feb4ba52cebb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b4dd9e35771ba842f0feb4ba52cebb9">clear</a> (<a class="el" href="classsf_1_1Color.html">Color</a> color, <a class="el" href="structsf_1_1StencilValue.html">StencilValue</a> stencilValue)</td></tr>
<tr class="memdesc:a6b4dd9e35771ba842f0feb4ba52cebb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the entire target with a single color and stencil value.  <br /></td></tr>
<tr class="separator:a6b4dd9e35771ba842f0feb4ba52cebb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063db6dd0a14913504af30e50cb6d946" id="r_a063db6dd0a14913504af30e50cb6d946"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a063db6dd0a14913504af30e50cb6d946">setView</a> (const <a class="el" href="classsf_1_1View.html">View</a> &amp;view)</td></tr>
<tr class="memdesc:a063db6dd0a14913504af30e50cb6d946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the current active view.  <br /></td></tr>
<tr class="separator:a063db6dd0a14913504af30e50cb6d946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf8dc5a1f4abbe15a3fbb915844c7ea" id="r_adbf8dc5a1f4abbe15a3fbb915844c7ea"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsf_1_1View.html">View</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbf8dc5a1f4abbe15a3fbb915844c7ea">getView</a> () const</td></tr>
<tr class="memdesc:adbf8dc5a1f4abbe15a3fbb915844c7ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the view currently in use in the render target.  <br /></td></tr>
<tr class="separator:adbf8dc5a1f4abbe15a3fbb915844c7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7741129e3ef7ab4f0a40024fca13480c" id="r_a7741129e3ef7ab4f0a40024fca13480c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsf_1_1View.html">View</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7741129e3ef7ab4f0a40024fca13480c">getDefaultView</a> () const</td></tr>
<tr class="memdesc:a7741129e3ef7ab4f0a40024fca13480c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default view of the render target.  <br /></td></tr>
<tr class="separator:a7741129e3ef7ab4f0a40024fca13480c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865d462915dc2a1fae2ebfb3300382ac" id="r_a865d462915dc2a1fae2ebfb3300382ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesf.html#add1cf75a734c8414680b0424145c30b1">IntRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a865d462915dc2a1fae2ebfb3300382ac">getViewport</a> (const <a class="el" href="classsf_1_1View.html">View</a> &amp;view) const</td></tr>
<tr class="memdesc:a865d462915dc2a1fae2ebfb3300382ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the viewport of a view, applied to this render target.  <br /></td></tr>
<tr class="separator:a865d462915dc2a1fae2ebfb3300382ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28db5c204007c2ccc806462ed6712da6" id="r_a28db5c204007c2ccc806462ed6712da6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesf.html#add1cf75a734c8414680b0424145c30b1">IntRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28db5c204007c2ccc806462ed6712da6">getScissor</a> (const <a class="el" href="classsf_1_1View.html">View</a> &amp;view) const</td></tr>
<tr class="memdesc:a28db5c204007c2ccc806462ed6712da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the scissor rectangle of a view, applied to this render target.  <br /></td></tr>
<tr class="separator:a28db5c204007c2ccc806462ed6712da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce02e4fd30e065c4dbeec239ae579b3" id="r_a5ce02e4fd30e065c4dbeec239ae579b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ce02e4fd30e065c4dbeec239ae579b3">mapPixelToCoords</a> (<a class="el" href="namespacesf.html#af0ffe1b157a56931ee3a9a1a771a827a">Vector2i</a> point) const</td></tr>
<tr class="memdesc:a5ce02e4fd30e065c4dbeec239ae579b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a point from target coordinates to world coordinates, using the current view.  <br /></td></tr>
<tr class="separator:a5ce02e4fd30e065c4dbeec239ae579b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c5ec0787ffdcabfcee0f2b88dd4536" id="r_af7c5ec0787ffdcabfcee0f2b88dd4536"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7c5ec0787ffdcabfcee0f2b88dd4536">mapPixelToCoords</a> (<a class="el" href="namespacesf.html#af0ffe1b157a56931ee3a9a1a771a827a">Vector2i</a> point, const <a class="el" href="classsf_1_1View.html">View</a> &amp;view) const</td></tr>
<tr class="memdesc:af7c5ec0787ffdcabfcee0f2b88dd4536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a point from target coordinates to world coordinates.  <br /></td></tr>
<tr class="separator:af7c5ec0787ffdcabfcee0f2b88dd4536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab473e0723ba16cf913deb03774c8458c" id="r_ab473e0723ba16cf913deb03774c8458c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesf.html#af0ffe1b157a56931ee3a9a1a771a827a">Vector2i</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab473e0723ba16cf913deb03774c8458c">mapCoordsToPixel</a> (<a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a> point) const</td></tr>
<tr class="memdesc:ab473e0723ba16cf913deb03774c8458c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a point from world coordinates to target coordinates, using the current view.  <br /></td></tr>
<tr class="separator:ab473e0723ba16cf913deb03774c8458c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a8da6e2a9e3ce5f36344e3d8e7c41a" id="r_a07a8da6e2a9e3ce5f36344e3d8e7c41a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesf.html#af0ffe1b157a56931ee3a9a1a771a827a">Vector2i</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07a8da6e2a9e3ce5f36344e3d8e7c41a">mapCoordsToPixel</a> (<a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a> point, const <a class="el" href="classsf_1_1View.html">View</a> &amp;view) const</td></tr>
<tr class="memdesc:a07a8da6e2a9e3ce5f36344e3d8e7c41a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a point from world coordinates to target coordinates.  <br /></td></tr>
<tr class="separator:a07a8da6e2a9e3ce5f36344e3d8e7c41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12417a3bcc245c41d957b29583556f39" id="r_a12417a3bcc245c41d957b29583556f39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12417a3bcc245c41d957b29583556f39">draw</a> (const <a class="el" href="classsf_1_1Drawable.html">Drawable</a> &amp;drawable, const <a class="el" href="structsf_1_1RenderStates.html">RenderStates</a> &amp;states=<a class="el" href="structsf_1_1RenderStates.html#ad29672df29f19ce50c3021d95f2bb062">RenderStates::Default</a>)</td></tr>
<tr class="memdesc:a12417a3bcc245c41d957b29583556f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a drawable object to the render target.  <br /></td></tr>
<tr class="separator:a12417a3bcc245c41d957b29583556f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976bc94057799eb9f8a18ac5fdfd9b73" id="r_a976bc94057799eb9f8a18ac5fdfd9b73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a976bc94057799eb9f8a18ac5fdfd9b73">draw</a> (const <a class="el" href="structsf_1_1Vertex.html">Vertex</a> *vertices, std::size_t vertexCount, <a class="el" href="group__graphics.html#ga5ee56ac1339984909610713096283b1b">PrimitiveType</a> type, const <a class="el" href="structsf_1_1RenderStates.html">RenderStates</a> &amp;states=<a class="el" href="structsf_1_1RenderStates.html#ad29672df29f19ce50c3021d95f2bb062">RenderStates::Default</a>)</td></tr>
<tr class="memdesc:a976bc94057799eb9f8a18ac5fdfd9b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw primitives defined by an array of vertices.  <br /></td></tr>
<tr class="separator:a976bc94057799eb9f8a18ac5fdfd9b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc4d06f081d36ca1e8f1a1298d49abc" id="r_a3dc4d06f081d36ca1e8f1a1298d49abc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3dc4d06f081d36ca1e8f1a1298d49abc">draw</a> (const <a class="el" href="classsf_1_1VertexBuffer.html">VertexBuffer</a> &amp;vertexBuffer, const <a class="el" href="structsf_1_1RenderStates.html">RenderStates</a> &amp;states=<a class="el" href="structsf_1_1RenderStates.html#ad29672df29f19ce50c3021d95f2bb062">RenderStates::Default</a>)</td></tr>
<tr class="memdesc:a3dc4d06f081d36ca1e8f1a1298d49abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw primitives defined by a vertex buffer.  <br /></td></tr>
<tr class="separator:a3dc4d06f081d36ca1e8f1a1298d49abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07cb25d4557a30146b24b25b242310ea" id="r_a07cb25d4557a30146b24b25b242310ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07cb25d4557a30146b24b25b242310ea">draw</a> (const <a class="el" href="classsf_1_1VertexBuffer.html">VertexBuffer</a> &amp;vertexBuffer, std::size_t firstVertex, std::size_t vertexCount, const <a class="el" href="structsf_1_1RenderStates.html">RenderStates</a> &amp;states=<a class="el" href="structsf_1_1RenderStates.html#ad29672df29f19ce50c3021d95f2bb062">RenderStates::Default</a>)</td></tr>
<tr class="memdesc:a07cb25d4557a30146b24b25b242310ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw primitives defined by a vertex buffer.  <br /></td></tr>
<tr class="separator:a07cb25d4557a30146b24b25b242310ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5ade2457d9fb4c4907ae5b3d9e94a5" id="r_a2e5ade2457d9fb4c4907ae5b3d9e94a5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacesf.html#adc674b5f5c13a6734954a18e01a73b42">Vector2u</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e5ade2457d9fb4c4907ae5b3d9e94a5">getSize</a> () const =0</td></tr>
<tr class="memdesc:a2e5ade2457d9fb4c4907ae5b3d9e94a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the rendering region of the target.  <br /></td></tr>
<tr class="separator:a2e5ade2457d9fb4c4907ae5b3d9e94a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6b58e5b2423c917e2664ecd4952687" id="r_aea6b58e5b2423c917e2664ecd4952687"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea6b58e5b2423c917e2664ecd4952687">isSrgb</a> () const</td></tr>
<tr class="memdesc:aea6b58e5b2423c917e2664ecd4952687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell if the render target will use sRGB encoding when drawing on it.  <br /></td></tr>
<tr class="separator:aea6b58e5b2423c917e2664ecd4952687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc225ead22a70843ffa9b7eebefa0ce1" id="r_adc225ead22a70843ffa9b7eebefa0ce1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc225ead22a70843ffa9b7eebefa0ce1">setActive</a> (bool active=true)</td></tr>
<tr class="memdesc:adc225ead22a70843ffa9b7eebefa0ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate or deactivate the render target for rendering.  <br /></td></tr>
<tr class="separator:adc225ead22a70843ffa9b7eebefa0ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1998464ccc54e789aaf990242b47f7" id="r_a8d1998464ccc54e789aaf990242b47f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d1998464ccc54e789aaf990242b47f7">pushGLStates</a> ()</td></tr>
<tr class="memdesc:a8d1998464ccc54e789aaf990242b47f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the current OpenGL render states and matrices.  <br /></td></tr>
<tr class="separator:a8d1998464ccc54e789aaf990242b47f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a98401113df931ddcd54c080f7aa8e" id="r_ad5a98401113df931ddcd54c080f7aa8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5a98401113df931ddcd54c080f7aa8e">popGLStates</a> ()</td></tr>
<tr class="memdesc:ad5a98401113df931ddcd54c080f7aa8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the previously saved OpenGL render states and matrices.  <br /></td></tr>
<tr class="separator:ad5a98401113df931ddcd54c080f7aa8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7504990d27dada4bfe3c7866920765" id="r_aac7504990d27dada4bfe3c7866920765"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac7504990d27dada4bfe3c7866920765">resetGLStates</a> ()</td></tr>
<tr class="memdesc:aac7504990d27dada4bfe3c7866920765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the internal OpenGL states so that the target is ready for drawing.  <br /></td></tr>
<tr class="separator:aac7504990d27dada4bfe3c7866920765"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a72f1cf9433b40b3f54a2efd9a2fe9a49" id="r_a72f1cf9433b40b3f54a2efd9a2fe9a49"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72f1cf9433b40b3f54a2efd9a2fe9a49">RenderTarget</a> ()=default</td></tr>
<tr class="memdesc:a72f1cf9433b40b3f54a2efd9a2fe9a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:a72f1cf9433b40b3f54a2efd9a2fe9a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af530274b34159d644e509b4b4dc43eb7" id="r_af530274b34159d644e509b4b4dc43eb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af530274b34159d644e509b4b4dc43eb7">initialize</a> ()</td></tr>
<tr class="memdesc:af530274b34159d644e509b4b4dc43eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the common initialization step after creation.  <br /></td></tr>
<tr class="separator:af530274b34159d644e509b4b4dc43eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for all render targets (window, texture, ...) </p>
<p><code><a class="el" href="classsf_1_1RenderTarget.html" title="Base class for all render targets (window, texture, ...)">sf::RenderTarget</a></code> defines the common behavior of all the 2D render targets usable in the graphics module.</p>
<p>It makes it possible to draw 2D entities like sprites, shapes, text without using any OpenGL command directly.</p>
<p>A <code><a class="el" href="classsf_1_1RenderTarget.html" title="Base class for all render targets (window, texture, ...)">sf::RenderTarget</a></code> is also able to use views (<code><a class="el" href="classsf_1_1View.html" title="2D camera that defines what region is shown on screen">sf::View</a></code>), which are a kind of 2D cameras. With views you can globally scroll, rotate or zoom everything that is drawn, without having to transform every single entity. See the documentation of <code><a class="el" href="classsf_1_1View.html" title="2D camera that defines what region is shown on screen">sf::View</a></code> for more details and sample pieces of code about this class.</p>
<p>On top of that, render targets are still able to render direct OpenGL stuff. It is even possible to mix together OpenGL calls and regular SFML drawing commands. When doing so, make sure that OpenGL states are not messed up by calling the <code>pushGLStates</code>/<code>popGLStates</code> functions.</p>
<p>While render targets are moveable, it is not valid to move them between threads. This will cause your program to crash. The problem boils down to OpenGL being limited with regard to how it works in multithreaded environments. Please ensure you only move render targets within the same thread.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classsf_1_1RenderWindow.html" title="Window that can serve as a target for 2D drawing.">sf::RenderWindow</a></code>, <code><a class="el" href="classsf_1_1RenderTexture.html" title="Target for off-screen 2D rendering into a texture.">sf::RenderTexture</a></code>, <code><a class="el" href="classsf_1_1View.html" title="2D camera that defines what region is shown on screen">sf::View</a></code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="RenderTarget_8hpp_source.html#l00062">62</a> of file <a class="el" href="RenderTarget_8hpp_source.html">RenderTarget.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab7da7ccb48bd3983b33fe359258ca71d" name="ab7da7ccb48bd3983b33fe359258ca71d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7da7ccb48bd3983b33fe359258ca71d">&#9670;&#160;</a></span>~RenderTarget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual sf::RenderTarget::~RenderTarget </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<a id="aec429e06ee84e7fbeaf00632afde191c" name="aec429e06ee84e7fbeaf00632afde191c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec429e06ee84e7fbeaf00632afde191c">&#9670;&#160;</a></span>RenderTarget() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sf::RenderTarget::RenderTarget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1RenderTarget.html">RenderTarget</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy constructor. </p>

</div>
</div>
<a id="aa076083f766b1b57d30ceb61cf216dff" name="aa076083f766b1b57d30ceb61cf216dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa076083f766b1b57d30ceb61cf216dff">&#9670;&#160;</a></span>RenderTarget() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sf::RenderTarget::RenderTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1RenderTarget.html">RenderTarget</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>

</div>
</div>
<a id="a72f1cf9433b40b3f54a2efd9a2fe9a49" name="a72f1cf9433b40b3f54a2efd9a2fe9a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f1cf9433b40b3f54a2efd9a2fe9a49">&#9670;&#160;</a></span>RenderTarget() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sf::RenderTarget::RenderTarget </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6b4dd9e35771ba842f0feb4ba52cebb9" name="a6b4dd9e35771ba842f0feb4ba52cebb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4dd9e35771ba842f0feb4ba52cebb9">&#9670;&#160;</a></span>clear() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::RenderTarget::clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1Color.html">Color</a></td>          <td class="paramname"><span class="paramname"><em>color</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsf_1_1StencilValue.html">StencilValue</a></td>          <td class="paramname"><span class="paramname"><em>stencilValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the entire target with a single color and stencil value. </p>
<p>The specified stencil value is truncated to the bit width of the current stencil buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>Fill color to use to clear the render target </td></tr>
    <tr><td class="paramname">stencilValue</td><td>Stencil value to clear to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee353fc2cd35edf0747e710301af3e4c" name="aee353fc2cd35edf0747e710301af3e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee353fc2cd35edf0747e710301af3e4c">&#9670;&#160;</a></span>clear() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::RenderTarget::clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1Color.html">Color</a></td>          <td class="paramname"><span class="paramname"><em>color</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classsf_1_1Color.html#a77c688197b981338f0b19dc58bd2facd">Color::Black</a></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the entire target with a single color. </p>
<p>This function is usually called once every frame, to clear the previous contents of the target.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>Fill color to use to clear the render target </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5756ecc36a0ad169809063f8f2563cbe" name="a5756ecc36a0ad169809063f8f2563cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5756ecc36a0ad169809063f8f2563cbe">&#9670;&#160;</a></span>clearStencil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::RenderTarget::clearStencil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsf_1_1StencilValue.html">StencilValue</a></td>          <td class="paramname"><span class="paramname"><em>stencilValue</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the stencil buffer to a specific value. </p>
<p>The specified value is truncated to the bit width of the current stencil buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stencilValue</td><td>Stencil value to clear to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12417a3bcc245c41d957b29583556f39" name="a12417a3bcc245c41d957b29583556f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12417a3bcc245c41d957b29583556f39">&#9670;&#160;</a></span>draw() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::RenderTarget::draw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Drawable.html">Drawable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>drawable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsf_1_1RenderStates.html">RenderStates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>states</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structsf_1_1RenderStates.html#ad29672df29f19ce50c3021d95f2bb062">RenderStates::Default</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a drawable object to the render target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">drawable</td><td>Object to draw </td></tr>
    <tr><td class="paramname">states</td><td>Render states to use for drawing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a976bc94057799eb9f8a18ac5fdfd9b73" name="a976bc94057799eb9f8a18ac5fdfd9b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976bc94057799eb9f8a18ac5fdfd9b73">&#9670;&#160;</a></span>draw() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::RenderTarget::draw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsf_1_1Vertex.html">Vertex</a> *</td>          <td class="paramname"><span class="paramname"><em>vertices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>vertexCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__graphics.html#ga5ee56ac1339984909610713096283b1b">PrimitiveType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsf_1_1RenderStates.html">RenderStates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>states</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structsf_1_1RenderStates.html#ad29672df29f19ce50c3021d95f2bb062">RenderStates::Default</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw primitives defined by an array of vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Pointer to the vertices </td></tr>
    <tr><td class="paramname">vertexCount</td><td>Number of vertices in the array </td></tr>
    <tr><td class="paramname">type</td><td>Type of primitives to draw </td></tr>
    <tr><td class="paramname">states</td><td>Render states to use for drawing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3dc4d06f081d36ca1e8f1a1298d49abc" name="a3dc4d06f081d36ca1e8f1a1298d49abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc4d06f081d36ca1e8f1a1298d49abc">&#9670;&#160;</a></span>draw() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::RenderTarget::draw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1VertexBuffer.html">VertexBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vertexBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsf_1_1RenderStates.html">RenderStates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>states</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structsf_1_1RenderStates.html#ad29672df29f19ce50c3021d95f2bb062">RenderStates::Default</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw primitives defined by a vertex buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexBuffer</td><td><a class="el" href="structsf_1_1Vertex.html" title="Point with color and texture coordinates.">Vertex</a> buffer </td></tr>
    <tr><td class="paramname">states</td><td>Render states to use for drawing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07cb25d4557a30146b24b25b242310ea" name="a07cb25d4557a30146b24b25b242310ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07cb25d4557a30146b24b25b242310ea">&#9670;&#160;</a></span>draw() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::RenderTarget::draw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1VertexBuffer.html">VertexBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vertexBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>firstVertex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>vertexCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsf_1_1RenderStates.html">RenderStates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>states</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structsf_1_1RenderStates.html#ad29672df29f19ce50c3021d95f2bb062">RenderStates::Default</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw primitives defined by a vertex buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexBuffer</td><td><a class="el" href="structsf_1_1Vertex.html" title="Point with color and texture coordinates.">Vertex</a> buffer </td></tr>
    <tr><td class="paramname">firstVertex</td><td>Index of the first vertex to render </td></tr>
    <tr><td class="paramname">vertexCount</td><td>Number of vertices to render </td></tr>
    <tr><td class="paramname">states</td><td>Render states to use for drawing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7741129e3ef7ab4f0a40024fca13480c" name="a7741129e3ef7ab4f0a40024fca13480c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7741129e3ef7ab4f0a40024fca13480c">&#9670;&#160;</a></span>getDefaultView()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsf_1_1View.html">View</a> &amp; sf::RenderTarget::getDefaultView </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the default view of the render target. </p>
<p>The default view has the initial size of the render target, and never changes after the target has been created.</p>
<dl class="section return"><dt>Returns</dt><dd>The default view of the render target</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#a063db6dd0a14913504af30e50cb6d946" title="Change the current active view.">setView</a></code>, <code><a class="el" href="#adbf8dc5a1f4abbe15a3fbb915844c7ea" title="Get the view currently in use in the render target.">getView</a></code> </dd></dl>

</div>
</div>
<a id="a28db5c204007c2ccc806462ed6712da6" name="a28db5c204007c2ccc806462ed6712da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28db5c204007c2ccc806462ed6712da6">&#9670;&#160;</a></span>getScissor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesf.html#add1cf75a734c8414680b0424145c30b1">IntRect</a> sf::RenderTarget::getScissor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1View.html">View</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>view</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the scissor rectangle of a view, applied to this render target. </p>
<p>The scissor rectangle is defined in the view as a ratio. This function simply applies this ratio to the current dimensions of the render target to calculate the pixels rectangle that the scissor rectangle actually covers in the target.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>The view for which we want to compute the scissor rectangle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Scissor rectangle, expressed in pixels </dd></dl>

</div>
</div>
<a id="a2e5ade2457d9fb4c4907ae5b3d9e94a5" name="a2e5ade2457d9fb4c4907ae5b3d9e94a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e5ade2457d9fb4c4907ae5b3d9e94a5">&#9670;&#160;</a></span>getSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacesf.html#adc674b5f5c13a6734954a18e01a73b42">Vector2u</a> sf::RenderTarget::getSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the size of the rendering region of the target. </p>
<dl class="section return"><dt>Returns</dt><dd>Size in pixels </dd></dl>

<p>Implemented in <a class="el" href="classsf_1_1RenderTexture.html#a7acc31207ad749f94805cbf4fa2acf03">sf::RenderTexture</a>, and <a class="el" href="classsf_1_1RenderWindow.html#af5d9a6263e05fd4ed4b31a5c202cc642">sf::RenderWindow</a>.</p>

</div>
</div>
<a id="adbf8dc5a1f4abbe15a3fbb915844c7ea" name="adbf8dc5a1f4abbe15a3fbb915844c7ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf8dc5a1f4abbe15a3fbb915844c7ea">&#9670;&#160;</a></span>getView()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsf_1_1View.html">View</a> &amp; sf::RenderTarget::getView </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the view currently in use in the render target. </p>
<dl class="section return"><dt>Returns</dt><dd>The view object that is currently used</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#a063db6dd0a14913504af30e50cb6d946" title="Change the current active view.">setView</a></code>, <code><a class="el" href="#a7741129e3ef7ab4f0a40024fca13480c" title="Get the default view of the render target.">getDefaultView</a></code> </dd></dl>

</div>
</div>
<a id="a865d462915dc2a1fae2ebfb3300382ac" name="a865d462915dc2a1fae2ebfb3300382ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865d462915dc2a1fae2ebfb3300382ac">&#9670;&#160;</a></span>getViewport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesf.html#add1cf75a734c8414680b0424145c30b1">IntRect</a> sf::RenderTarget::getViewport </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1View.html">View</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>view</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the viewport of a view, applied to this render target. </p>
<p>The viewport is defined in the view as a ratio, this function simply applies this ratio to the current dimensions of the render target to calculate the pixels rectangle that the viewport actually covers in the target.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>The view for which we want to compute the viewport</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Viewport rectangle, expressed in pixels </dd></dl>

</div>
</div>
<a id="af530274b34159d644e509b4b4dc43eb7" name="af530274b34159d644e509b4b4dc43eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af530274b34159d644e509b4b4dc43eb7">&#9670;&#160;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::RenderTarget::initialize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the common initialization step after creation. </p>
<p>The derived classes must call this function after the target is created and ready for drawing. </p>

</div>
</div>
<a id="aea6b58e5b2423c917e2664ecd4952687" name="aea6b58e5b2423c917e2664ecd4952687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6b58e5b2423c917e2664ecd4952687">&#9670;&#160;</a></span>isSrgb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sf::RenderTarget::isSrgb </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell if the render target will use sRGB encoding when drawing on it. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the render target use sRGB encoding, <code>false</code> otherwise </dd></dl>

<p>Reimplemented in <a class="el" href="classsf_1_1RenderTexture.html#ac9c9abcd802917012c50009f7b662c0c">sf::RenderTexture</a>, and <a class="el" href="classsf_1_1RenderWindow.html#a1e57e5284d9abf1095171d157dd27b3f">sf::RenderWindow</a>.</p>

</div>
</div>
<a id="ab473e0723ba16cf913deb03774c8458c" name="ab473e0723ba16cf913deb03774c8458c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab473e0723ba16cf913deb03774c8458c">&#9670;&#160;</a></span>mapCoordsToPixel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesf.html#af0ffe1b157a56931ee3a9a1a771a827a">Vector2i</a> sf::RenderTarget::mapCoordsToPixel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a></td>          <td class="paramname"><span class="paramname"><em>point</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a point from world coordinates to target coordinates, using the current view. </p>
<p>This function is an overload of the <code>mapCoordsToPixel</code> function that implicitly uses the current view. It is equivalent to: </p><div class="fragment"><div class="line">target.mapCoordsToPixel(point, target.getView());</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>Point to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted point, in target coordinates (pixels)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#a5ce02e4fd30e065c4dbeec239ae579b3" title="Convert a point from target coordinates to world coordinates, using the current view.">mapPixelToCoords</a></code> </dd></dl>

</div>
</div>
<a id="a07a8da6e2a9e3ce5f36344e3d8e7c41a" name="a07a8da6e2a9e3ce5f36344e3d8e7c41a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a8da6e2a9e3ce5f36344e3d8e7c41a">&#9670;&#160;</a></span>mapCoordsToPixel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesf.html#af0ffe1b157a56931ee3a9a1a771a827a">Vector2i</a> sf::RenderTarget::mapCoordsToPixel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a></td>          <td class="paramname"><span class="paramname"><em>point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsf_1_1View.html">View</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>view</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a point from world coordinates to target coordinates. </p>
<p>This function finds the pixel of the render target that matches the given 2D point. In other words, it goes through the same process as the graphics card, to compute the final position of a rendered point.</p>
<p>Initially, both coordinate systems (world units and target pixels) match perfectly. But if you define a custom view or resize your render target, this assertion is not <code>true</code> anymore, i.e. a point located at (150, 75) in your 2D world may map to the pixel (10, 50) of your render target &ndash; if the view is translated by (140, 25).</p>
<p>This version uses a custom view for calculations, see the other overload of the function if you want to use the current view of the render target.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>Point to convert </td></tr>
    <tr><td class="paramname">view</td><td>The view to use for converting the point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted point, in target coordinates (pixels)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#a5ce02e4fd30e065c4dbeec239ae579b3" title="Convert a point from target coordinates to world coordinates, using the current view.">mapPixelToCoords</a></code> </dd></dl>

</div>
</div>
<a id="a5ce02e4fd30e065c4dbeec239ae579b3" name="a5ce02e4fd30e065c4dbeec239ae579b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce02e4fd30e065c4dbeec239ae579b3">&#9670;&#160;</a></span>mapPixelToCoords() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a> sf::RenderTarget::mapPixelToCoords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesf.html#af0ffe1b157a56931ee3a9a1a771a827a">Vector2i</a></td>          <td class="paramname"><span class="paramname"><em>point</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a point from target coordinates to world coordinates, using the current view. </p>
<p>This function is an overload of the mapPixelToCoords function that implicitly uses the current view. It is equivalent to: </p><div class="fragment"><div class="line">target.mapPixelToCoords(point, target.getView());</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>Pixel to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted point, in "world" coordinates</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#ab473e0723ba16cf913deb03774c8458c" title="Convert a point from world coordinates to target coordinates, using the current view.">mapCoordsToPixel</a></code> </dd></dl>

</div>
</div>
<a id="af7c5ec0787ffdcabfcee0f2b88dd4536" name="af7c5ec0787ffdcabfcee0f2b88dd4536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c5ec0787ffdcabfcee0f2b88dd4536">&#9670;&#160;</a></span>mapPixelToCoords() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a> sf::RenderTarget::mapPixelToCoords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesf.html#af0ffe1b157a56931ee3a9a1a771a827a">Vector2i</a></td>          <td class="paramname"><span class="paramname"><em>point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsf_1_1View.html">View</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>view</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a point from target coordinates to world coordinates. </p>
<p>This function finds the 2D position that matches the given pixel of the render target. In other words, it does the inverse of what the graphics card does, to find the initial position of a rendered pixel.</p>
<p>Initially, both coordinate systems (world units and target pixels) match perfectly. But if you define a custom view or resize your render target, this assertion is not <code>true</code> anymore, i.e. a point located at (10, 50) in your render target may map to the point (150, 75) in your 2D world &ndash; if the view is translated by (140, 25).</p>
<p>For render-windows, this function is typically used to find which point (or object) is located below the mouse cursor.</p>
<p>This version uses a custom view for calculations, see the other overload of the function if you want to use the current view of the render target.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>Pixel to convert </td></tr>
    <tr><td class="paramname">view</td><td>The view to use for converting the point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted point, in "world" units</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#ab473e0723ba16cf913deb03774c8458c" title="Convert a point from world coordinates to target coordinates, using the current view.">mapCoordsToPixel</a></code> </dd></dl>

</div>
</div>
<a id="ab18bb39bb3a26766582fad362516ac2e" name="ab18bb39bb3a26766582fad362516ac2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab18bb39bb3a26766582fad362516ac2e">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1RenderTarget.html">RenderTarget</a> &amp; sf::RenderTarget::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1RenderTarget.html">RenderTarget</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy assignment. </p>

</div>
</div>
<a id="ae94e144a10d39e6f84d50bea6e18cb10" name="ae94e144a10d39e6f84d50bea6e18cb10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94e144a10d39e6f84d50bea6e18cb10">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1RenderTarget.html">RenderTarget</a> &amp; sf::RenderTarget::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1RenderTarget.html">RenderTarget</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment. </p>

</div>
</div>
<a id="ad5a98401113df931ddcd54c080f7aa8e" name="ad5a98401113df931ddcd54c080f7aa8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a98401113df931ddcd54c080f7aa8e">&#9670;&#160;</a></span>popGLStates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::RenderTarget::popGLStates </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore the previously saved OpenGL render states and matrices. </p>
<p>See the description of <code>pushGLStates</code> to get a detailed description of these functions.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#a8d1998464ccc54e789aaf990242b47f7" title="Save the current OpenGL render states and matrices.">pushGLStates</a></code> </dd></dl>

</div>
</div>
<a id="a8d1998464ccc54e789aaf990242b47f7" name="a8d1998464ccc54e789aaf990242b47f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1998464ccc54e789aaf990242b47f7">&#9670;&#160;</a></span>pushGLStates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::RenderTarget::pushGLStates </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the current OpenGL render states and matrices. </p>
<p>This function can be used when you mix SFML drawing and direct OpenGL rendering. Combined with popGLStates, it ensures that: </p><ul>
<li>SFML's internal states are not messed up by your OpenGL code </li>
<li>your OpenGL states are not modified by a call to a SFML function</li>
</ul>
<p>More specifically, it must be used around code that calls <code>draw</code> functions. Example: </p><div class="fragment"><div class="line"><span class="comment">// OpenGL code here...</span></div>
<div class="line">window.pushGLStates();</div>
<div class="line">window.draw(...);</div>
<div class="line">window.draw(...);</div>
<div class="line">window.popGLStates();</div>
<div class="line"><span class="comment">// OpenGL code here...</span></div>
</div><!-- fragment --><p>Note that this function is quite expensive: it saves all the possible OpenGL states and matrices, even the ones you don't care about. Therefore it should be used wisely. It is provided for convenience, but the best results will be achieved if you handle OpenGL states yourself (because you know which states have really changed, and need to be saved and restored). Take a look at the resetGLStates function if you do so.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#ad5a98401113df931ddcd54c080f7aa8e" title="Restore the previously saved OpenGL render states and matrices.">popGLStates</a></code> </dd></dl>

</div>
</div>
<a id="aac7504990d27dada4bfe3c7866920765" name="aac7504990d27dada4bfe3c7866920765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac7504990d27dada4bfe3c7866920765">&#9670;&#160;</a></span>resetGLStates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::RenderTarget::resetGLStates </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the internal OpenGL states so that the target is ready for drawing. </p>
<p>This function can be used when you mix SFML drawing and direct OpenGL rendering, if you choose not to use <code>pushGLStates</code>/<code>popGLStates</code>. It makes sure that all OpenGL states needed by SFML are set, so that subsequent <code><a class="el" href="#a12417a3bcc245c41d957b29583556f39" title="Draw a drawable object to the render target.">draw()</a></code> calls will work as expected.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// OpenGL code here...</span></div>
<div class="line">glPushAttrib(...);</div>
<div class="line">window.resetGLStates();</div>
<div class="line">window.draw(...);</div>
<div class="line">window.draw(...);</div>
<div class="line">glPopAttrib(...);</div>
<div class="line"><span class="comment">// OpenGL code here...</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="adc225ead22a70843ffa9b7eebefa0ce1" name="adc225ead22a70843ffa9b7eebefa0ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc225ead22a70843ffa9b7eebefa0ce1">&#9670;&#160;</a></span>setActive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sf::RenderTarget::setActive </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>active</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Activate or deactivate the render target for rendering. </p>
<p>This function makes the render target's context current for future OpenGL rendering operations (so you shouldn't care about it if you're not doing direct OpenGL stuff). A render target's context is active only on the current thread, if you want to make it active on another thread you have to deactivate it on the previous thread first if it was active. Only one context can be current in a thread, so if you want to draw OpenGL geometry to another render target don't forget to activate it again. Activating a render target will automatically deactivate the previously active context (if any).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">active</td><td><code>true</code> to activate, <code>false</code> to deactivate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if operation was successful, <code>false</code> otherwise </dd></dl>

<p>Reimplemented in <a class="el" href="classsf_1_1RenderTexture.html#a30eda291b7b7179e7a0d1506c953a424">sf::RenderTexture</a>, and <a class="el" href="classsf_1_1RenderWindow.html#a3f5476821139d5a7f0e4df19dab69b56">sf::RenderWindow</a>.</p>

</div>
</div>
<a id="a063db6dd0a14913504af30e50cb6d946" name="a063db6dd0a14913504af30e50cb6d946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a063db6dd0a14913504af30e50cb6d946">&#9670;&#160;</a></span>setView()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::RenderTarget::setView </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1View.html">View</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>view</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the current active view. </p>
<p>The view is like a 2D camera, it controls which part of the 2D scene is visible, and how it is viewed in the render target. The new view will affect everything that is drawn, until another view is set. The render target keeps its own copy of the view object, so it is not necessary to keep the original one alive after calling this function. To restore the original view of the target, you can pass the result of <code><a class="el" href="#a7741129e3ef7ab4f0a40024fca13480c" title="Get the default view of the render target.">getDefaultView()</a></code> to this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>New view to use</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#adbf8dc5a1f4abbe15a3fbb915844c7ea" title="Get the view currently in use in the render target.">getView</a></code>, <code><a class="el" href="#a7741129e3ef7ab4f0a40024fca13480c" title="Get the default view of the render target.">getDefaultView</a></code> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="RenderTarget_8hpp_source.html">RenderTarget.hpp</a></li>
</ul>
</div><!-- contents -->
        </div>
        <div id="footer-container">
            <div id="footer">
                SFML is licensed under the terms and conditions of the <a href="https://www.sfml-dev.org/license.php">zlib/png license</a>.<br />
                Copyright &copy; Laurent Gomila &nbsp;::&nbsp;
                Documentation generated by <a href="http://www.doxygen.org/" title="doxygen website">doxygen</a> &nbsp;::&nbsp;
            </div>
        </div>
    </body>
</html>
