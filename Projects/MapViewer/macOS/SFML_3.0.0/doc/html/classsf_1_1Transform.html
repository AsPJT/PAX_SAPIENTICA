<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>SFML - Simple and Fast Multimedia Library</title>
        <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
        <link rel="stylesheet" type="text/css" href="doxygen.css" title="default" media="screen,print" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
        <script type="text/javascript" src="clipboard.js"></script>
        <script type="text/javascript" src="cookie.js"></script>
        <link rel="stylesheet" type="text/css" href="search/search.css" />
        <link rel="stylesheet" type="text/css" href="searchOverrides.css" />
        <script type="text/javascript" src="search/searchdata.js"></script>
        <script type="text/javascript" src="search/search.js"></script>
        <script type="text/javascript">
        /* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
          $(document).ready(function() { init_search(); });
        /* @license-end */
        </script>
    </head>
    <body>
        <div id="banner-container">
            <div id="banner">
                <span id="sfml">SFML 3.0.0</span>
            </div>
        </div>
        <div id="content">
            <div>
<!-- Generated by Doxygen 1.13.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="topics.html"><span>Topics</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesf.html">sf</a></li><li class="navelem"><a class="el" href="classsf_1_1Transform.html">Transform</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#related">Related Symbols</a> &#124;
<a href="classsf_1_1Transform-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">sf::Transform Class Reference<div class="ingroups"><a class="el" href="group__graphics.html">Graphics module</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>3x3 transform matrix  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Transform_8hpp_source.html">SFML/Graphics/Transform.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a77f097203662eb2de0ab9baa2bfe44c4" id="r_a77f097203662eb2de0ab9baa2bfe44c4"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77f097203662eb2de0ab9baa2bfe44c4">Transform</a> ()=default</td></tr>
<tr class="memdesc:a77f097203662eb2de0ab9baa2bfe44c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:a77f097203662eb2de0ab9baa2bfe44c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475928bf989a8e23deffa2e5ab5e1c22" id="r_a475928bf989a8e23deffa2e5ab5e1c22"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a475928bf989a8e23deffa2e5ab5e1c22">Transform</a> (float a00, float a01, float a02, float a10, float a11, float a12, float a20, float a21, float a22)</td></tr>
<tr class="memdesc:a475928bf989a8e23deffa2e5ab5e1c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a transform from a 3x3 matrix.  <br /></td></tr>
<tr class="separator:a475928bf989a8e23deffa2e5ab5e1c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74f38379f76fc926acb06378f68ab98" id="r_af74f38379f76fc926acb06378f68ab98"><td class="memItemLeft" align="right" valign="top">constexpr const float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af74f38379f76fc926acb06378f68ab98">getMatrix</a> () const</td></tr>
<tr class="memdesc:af74f38379f76fc926acb06378f68ab98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the transform as a 4x4 matrix.  <br /></td></tr>
<tr class="separator:af74f38379f76fc926acb06378f68ab98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f21cb9c981394e48abc183c55cd7bf" id="r_ae1f21cb9c981394e48abc183c55cd7bf"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classsf_1_1Transform.html">Transform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1f21cb9c981394e48abc183c55cd7bf">getInverse</a> () const</td></tr>
<tr class="memdesc:ae1f21cb9c981394e48abc183c55cd7bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the inverse of the transform.  <br /></td></tr>
<tr class="separator:ae1f21cb9c981394e48abc183c55cd7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64eb34f1465339dd28f801ad85f881d3" id="r_a64eb34f1465339dd28f801ad85f881d3"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64eb34f1465339dd28f801ad85f881d3">transformPoint</a> (<a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a> point) const</td></tr>
<tr class="memdesc:a64eb34f1465339dd28f801ad85f881d3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsf_1_1Transform.html" title="3x3 transform matrix">Transform</a> a 2D point.  <br /></td></tr>
<tr class="separator:a64eb34f1465339dd28f801ad85f881d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc4d0e5221d792de5cbcafb44414887" id="r_a7fc4d0e5221d792de5cbcafb44414887"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacesf.html#a701020eb396e62ba560619e68c689a38">FloatRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fc4d0e5221d792de5cbcafb44414887">transformRect</a> (const <a class="el" href="namespacesf.html#a701020eb396e62ba560619e68c689a38">FloatRect</a> &amp;rectangle) const</td></tr>
<tr class="memdesc:a7fc4d0e5221d792de5cbcafb44414887"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsf_1_1Transform.html" title="3x3 transform matrix">Transform</a> a rectangle.  <br /></td></tr>
<tr class="separator:a7fc4d0e5221d792de5cbcafb44414887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd62a1198c278851c2031b1de1f906e" id="r_adcd62a1198c278851c2031b1de1f906e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classsf_1_1Transform.html">Transform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcd62a1198c278851c2031b1de1f906e">combine</a> (const <a class="el" href="classsf_1_1Transform.html">Transform</a> &amp;transform)</td></tr>
<tr class="memdesc:adcd62a1198c278851c2031b1de1f906e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine the current transform with another one.  <br /></td></tr>
<tr class="separator:adcd62a1198c278851c2031b1de1f906e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e1b0572a4703d9c23b01428f6494e3" id="r_a92e1b0572a4703d9c23b01428f6494e3"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classsf_1_1Transform.html">Transform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92e1b0572a4703d9c23b01428f6494e3">translate</a> (<a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a> offset)</td></tr>
<tr class="memdesc:a92e1b0572a4703d9c23b01428f6494e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine the current transform with a translation.  <br /></td></tr>
<tr class="separator:a92e1b0572a4703d9c23b01428f6494e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7172312b6e9aefce6a8cce4473363a69" id="r_a7172312b6e9aefce6a8cce4473363a69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsf_1_1Transform.html">Transform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7172312b6e9aefce6a8cce4473363a69">rotate</a> (<a class="el" href="classsf_1_1Angle.html">Angle</a> angle)</td></tr>
<tr class="memdesc:a7172312b6e9aefce6a8cce4473363a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine the current transform with a rotation.  <br /></td></tr>
<tr class="separator:a7172312b6e9aefce6a8cce4473363a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace37c565cb78b73b9c5009e7842bcd73" id="r_ace37c565cb78b73b9c5009e7842bcd73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsf_1_1Transform.html">Transform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace37c565cb78b73b9c5009e7842bcd73">rotate</a> (<a class="el" href="classsf_1_1Angle.html">Angle</a> angle, <a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a> center)</td></tr>
<tr class="memdesc:ace37c565cb78b73b9c5009e7842bcd73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine the current transform with a rotation.  <br /></td></tr>
<tr class="separator:ace37c565cb78b73b9c5009e7842bcd73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a14d89a99fe085164bdd083c88953a" id="r_ab0a14d89a99fe085164bdd083c88953a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classsf_1_1Transform.html">Transform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0a14d89a99fe085164bdd083c88953a">scale</a> (<a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a> factors)</td></tr>
<tr class="memdesc:ab0a14d89a99fe085164bdd083c88953a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine the current transform with a scaling.  <br /></td></tr>
<tr class="separator:ab0a14d89a99fe085164bdd083c88953a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6746da32321c7cfec595bfaff5243d0d" id="r_a6746da32321c7cfec595bfaff5243d0d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classsf_1_1Transform.html">Transform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6746da32321c7cfec595bfaff5243d0d">scale</a> (<a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a> factors, <a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a> center)</td></tr>
<tr class="memdesc:a6746da32321c7cfec595bfaff5243d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine the current transform with a scaling.  <br /></td></tr>
<tr class="separator:a6746da32321c7cfec595bfaff5243d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aa4eb1eecbcb9979d76e2543b337fdb13" id="r_aa4eb1eecbcb9979d76e2543b337fdb13"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classsf_1_1Transform.html">Transform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4eb1eecbcb9979d76e2543b337fdb13">Identity</a></td></tr>
<tr class="memdesc:aa4eb1eecbcb9979d76e2543b337fdb13"><td class="mdescLeft">&#160;</td><td class="mdescRight">The identity transform (does nothing)  <br /></td></tr>
<tr class="separator:aa4eb1eecbcb9979d76e2543b337fdb13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Symbols</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member symbols.) </p>
</td></tr>
<tr class="memitem:afe3eefbdbe67540f2f7468f7262edf62" id="r_afe3eefbdbe67540f2f7468f7262edf62"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classsf_1_1Transform.html">Transform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe3eefbdbe67540f2f7468f7262edf62">operator*</a> (const <a class="el" href="classsf_1_1Transform.html">Transform</a> &amp;left, const <a class="el" href="classsf_1_1Transform.html">Transform</a> &amp;right)</td></tr>
<tr class="memdesc:afe3eefbdbe67540f2f7468f7262edf62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of binary <code>operator*</code> to combine two transforms.  <br /></td></tr>
<tr class="separator:afe3eefbdbe67540f2f7468f7262edf62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aee0009a8c1675802c5d4565b592fd7" id="r_a3aee0009a8c1675802c5d4565b592fd7"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classsf_1_1Transform.html">Transform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3aee0009a8c1675802c5d4565b592fd7">operator*=</a> (<a class="el" href="classsf_1_1Transform.html">Transform</a> &amp;left, const <a class="el" href="classsf_1_1Transform.html">Transform</a> &amp;right)</td></tr>
<tr class="memdesc:a3aee0009a8c1675802c5d4565b592fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of binary <code>operator*=</code> to combine two transforms.  <br /></td></tr>
<tr class="separator:a3aee0009a8c1675802c5d4565b592fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b2481b28513108db3aca07dc77d3a3" id="r_a18b2481b28513108db3aca07dc77d3a3"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18b2481b28513108db3aca07dc77d3a3">operator*</a> (const <a class="el" href="classsf_1_1Transform.html">Transform</a> &amp;left, <a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a> right)</td></tr>
<tr class="memdesc:a18b2481b28513108db3aca07dc77d3a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of binary <code>operator*</code> to transform a point.  <br /></td></tr>
<tr class="separator:a18b2481b28513108db3aca07dc77d3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18d835d37f65fa22b703c243f83dc29" id="r_aa18d835d37f65fa22b703c243f83dc29"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa18d835d37f65fa22b703c243f83dc29">operator==</a> (const <a class="el" href="classsf_1_1Transform.html">Transform</a> &amp;left, const <a class="el" href="classsf_1_1Transform.html">Transform</a> &amp;right)</td></tr>
<tr class="memdesc:aa18d835d37f65fa22b703c243f83dc29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of binary <code>operator==</code> to compare two transforms.  <br /></td></tr>
<tr class="separator:aa18d835d37f65fa22b703c243f83dc29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb4691413724c6d2b580c1615170dd2" id="r_a6cb4691413724c6d2b580c1615170dd2"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cb4691413724c6d2b580c1615170dd2">operator!=</a> (const <a class="el" href="classsf_1_1Transform.html">Transform</a> &amp;left, const <a class="el" href="classsf_1_1Transform.html">Transform</a> &amp;right)</td></tr>
<tr class="memdesc:a6cb4691413724c6d2b580c1615170dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of binary <code>operator!=</code> to compare two transforms.  <br /></td></tr>
<tr class="separator:a6cb4691413724c6d2b580c1615170dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>3x3 transform matrix </p>
<p>A <code><a class="el" href="classsf_1_1Transform.html" title="3x3 transform matrix">sf::Transform</a></code> specifies how to translate, rotate, scale, shear, project, whatever things.</p>
<p>In mathematical terms, it defines how to transform a coordinate system into another.</p>
<p>For example, if you apply a rotation transform to a sprite, the result will be a rotated sprite. And anything that is transformed by this rotation transform will be rotated the same way, according to its initial position.</p>
<p>Transforms are typically used for drawing. But they can also be used for any computation that requires to transform points between the local and global coordinate systems of an entity (like collision detection).</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// define a translation transform</span></div>
<div class="line"><a class="code hl_class" href="classsf_1_1Transform.html">sf::Transform</a> translation;</div>
<div class="line">translation.<a class="code hl_function" href="#a92e1b0572a4703d9c23b01428f6494e3">translate</a>(20, 50);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// define a rotation transform</span></div>
<div class="line"><a class="code hl_class" href="classsf_1_1Transform.html">sf::Transform</a> rotation;</div>
<div class="line">rotation.<a class="code hl_function" href="#a7172312b6e9aefce6a8cce4473363a69">rotate</a>(45);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// combine them</span></div>
<div class="line"><a class="code hl_class" href="classsf_1_1Transform.html">sf::Transform</a> transform = translation * rotation;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// use the result to transform stuff...</span></div>
<div class="line"><a class="code hl_typedef" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">sf::Vector2f</a> point = transform.<a class="code hl_function" href="#a64eb34f1465339dd28f801ad85f881d3">transformPoint</a>({10, 20});</div>
<div class="line"><a class="code hl_typedef" href="namespacesf.html#a701020eb396e62ba560619e68c689a38">sf::FloatRect</a> rect = transform.<a class="code hl_function" href="#a7fc4d0e5221d792de5cbcafb44414887">transformRect</a>(<a class="code hl_typedef" href="namespacesf.html#a701020eb396e62ba560619e68c689a38">sf::FloatRect</a>({0, 0}, {10, 100}));</div>
<div class="ttc" id="aclasssf_1_1Transform_html"><div class="ttname"><a href="classsf_1_1Transform.html">sf::Transform</a></div><div class="ttdoc">3x3 transform matrix</div><div class="ttdef"><b>Definition</b> <a href="Transform_8hpp_source.html#l00047">Transform.hpp:48</a></div></div>
<div class="ttc" id="aclasssf_1_1Transform_html_a64eb34f1465339dd28f801ad85f881d3"><div class="ttname"><a href="#a64eb34f1465339dd28f801ad85f881d3">sf::Transform::transformPoint</a></div><div class="ttdeci">constexpr Vector2f transformPoint(Vector2f point) const</div><div class="ttdoc">Transform a 2D point.</div></div>
<div class="ttc" id="aclasssf_1_1Transform_html_a7172312b6e9aefce6a8cce4473363a69"><div class="ttname"><a href="#a7172312b6e9aefce6a8cce4473363a69">sf::Transform::rotate</a></div><div class="ttdeci">Transform &amp; rotate(Angle angle)</div><div class="ttdoc">Combine the current transform with a rotation.</div></div>
<div class="ttc" id="aclasssf_1_1Transform_html_a7fc4d0e5221d792de5cbcafb44414887"><div class="ttname"><a href="#a7fc4d0e5221d792de5cbcafb44414887">sf::Transform::transformRect</a></div><div class="ttdeci">constexpr FloatRect transformRect(const FloatRect &amp;rectangle) const</div><div class="ttdoc">Transform a rectangle.</div></div>
<div class="ttc" id="aclasssf_1_1Transform_html_a92e1b0572a4703d9c23b01428f6494e3"><div class="ttname"><a href="#a92e1b0572a4703d9c23b01428f6494e3">sf::Transform::translate</a></div><div class="ttdeci">constexpr Transform &amp; translate(Vector2f offset)</div><div class="ttdoc">Combine the current transform with a translation.</div></div>
<div class="ttc" id="anamespacesf_html_a701020eb396e62ba560619e68c689a38"><div class="ttname"><a href="namespacesf.html#a701020eb396e62ba560619e68c689a38">sf::FloatRect</a></div><div class="ttdeci">Rect&lt; float &gt; FloatRect</div><div class="ttdef"><b>Definition</b> <a href="Rect_8hpp_source.html#l00147">Rect.hpp:147</a></div></div>
<div class="ttc" id="anamespacesf_html_af14b40e82368dd601a7ef8037214804d"><div class="ttname"><a href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">sf::Vector2f</a></div><div class="ttdeci">Vector2&lt; float &gt; Vector2f</div><div class="ttdef"><b>Definition</b> <a href="Vector2_8hpp_source.html#l00210">Vector2.hpp:210</a></div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classsf_1_1Transformable.html" title="Decomposed transform defined by a position, a rotation and a scale.">sf::Transformable</a></code>, <code><a class="el" href="structsf_1_1RenderStates.html" title="Define the states used for drawing to a RenderTarget">sf::RenderStates</a></code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="Transform_8hpp_source.html#l00047">47</a> of file <a class="el" href="Transform_8hpp_source.html">Transform.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a77f097203662eb2de0ab9baa2bfe44c4" name="a77f097203662eb2de0ab9baa2bfe44c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f097203662eb2de0ab9baa2bfe44c4">&#9670;&#160;</a></span>Transform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sf::Transform::Transform </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Creates an identity transform (a transform that does nothing). </p>

</div>
</div>
<a id="a475928bf989a8e23deffa2e5ab5e1c22" name="a475928bf989a8e23deffa2e5ab5e1c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a475928bf989a8e23deffa2e5ab5e1c22">&#9670;&#160;</a></span>Transform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sf::Transform::Transform </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>a00</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>a01</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>a02</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>a10</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>a11</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>a12</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>a20</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>a21</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>a22</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a transform from a 3x3 matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a00</td><td>Element (0, 0) of the matrix </td></tr>
    <tr><td class="paramname">a01</td><td>Element (0, 1) of the matrix </td></tr>
    <tr><td class="paramname">a02</td><td>Element (0, 2) of the matrix </td></tr>
    <tr><td class="paramname">a10</td><td>Element (1, 0) of the matrix </td></tr>
    <tr><td class="paramname">a11</td><td>Element (1, 1) of the matrix </td></tr>
    <tr><td class="paramname">a12</td><td>Element (1, 2) of the matrix </td></tr>
    <tr><td class="paramname">a20</td><td>Element (2, 0) of the matrix </td></tr>
    <tr><td class="paramname">a21</td><td>Element (2, 1) of the matrix </td></tr>
    <tr><td class="paramname">a22</td><td>Element (2, 2) of the matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adcd62a1198c278851c2031b1de1f906e" name="adcd62a1198c278851c2031b1de1f906e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd62a1198c278851c2031b1de1f906e">&#9670;&#160;</a></span>combine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Transform.html">Transform</a> &amp; sf::Transform::combine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Transform.html">Transform</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>transform</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combine the current transform with another one. </p>
<p>The result is a transform that is equivalent to applying <code>transform</code> followed by <code>*this</code>. Mathematically, it is equivalent to a matrix multiplication <code>(*this) * transform</code>.</p>
<p>These two statements are equivalent: </p><div class="fragment"><div class="line">left.combine(right);</div>
<div class="line">left *= right;</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td><a class="el" href="classsf_1_1Transform.html" title="3x3 transform matrix">Transform</a> to combine with this transform</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to <code>*this</code> </dd></dl>

</div>
</div>
<a id="ae1f21cb9c981394e48abc183c55cd7bf" name="ae1f21cb9c981394e48abc183c55cd7bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f21cb9c981394e48abc183c55cd7bf">&#9670;&#160;</a></span>getInverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Transform.html">Transform</a> sf::Transform::getInverse </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the inverse of the transform. </p>
<p>If the inverse cannot be computed, an identity transform is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>A new transform which is the inverse of self </dd></dl>

</div>
</div>
<a id="af74f38379f76fc926acb06378f68ab98" name="af74f38379f76fc926acb06378f68ab98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74f38379f76fc926acb06378f68ab98">&#9670;&#160;</a></span>getMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const float * sf::Transform::getMatrix </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the transform as a 4x4 matrix. </p>
<p>This function returns a pointer to an array of 16 floats containing the transform elements as a 4x4 matrix, which is directly compatible with OpenGL functions.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsf_1_1Transform.html">sf::Transform</a> transform = ...;</div>
<div class="line">glLoadMatrixf(transform.<a class="code hl_function" href="#af74f38379f76fc926acb06378f68ab98">getMatrix</a>());</div>
<div class="ttc" id="aclasssf_1_1Transform_html_af74f38379f76fc926acb06378f68ab98"><div class="ttname"><a href="#af74f38379f76fc926acb06378f68ab98">sf::Transform::getMatrix</a></div><div class="ttdeci">constexpr const float * getMatrix() const</div><div class="ttdoc">Return the transform as a 4x4 matrix.</div></div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Pointer to a 4x4 matrix </dd></dl>

</div>
</div>
<a id="a7172312b6e9aefce6a8cce4473363a69" name="a7172312b6e9aefce6a8cce4473363a69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7172312b6e9aefce6a8cce4473363a69">&#9670;&#160;</a></span>rotate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Transform.html">Transform</a> &amp; sf::Transform::rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1Angle.html">Angle</a></td>          <td class="paramname"><span class="paramname"><em>angle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine the current transform with a rotation. </p>
<p>This function returns a reference to <code>*this</code>, so that calls can be chained. </p><div class="fragment"><div class="line"><a class="code hl_class" href="classsf_1_1Transform.html">sf::Transform</a> transform;</div>
<div class="line">transform.<a class="code hl_function" href="#a7172312b6e9aefce6a8cce4473363a69">rotate</a>(<a class="code hl_function" href="namespacesf.html#a956d8e2dd821777ce475c0856bfa879d">sf::degrees</a>(90)).<a class="code hl_function" href="#a92e1b0572a4703d9c23b01428f6494e3">translate</a>(50, 20);</div>
<div class="ttc" id="anamespacesf_html_a956d8e2dd821777ce475c0856bfa879d"><div class="ttname"><a href="namespacesf.html#a956d8e2dd821777ce475c0856bfa879d">sf::degrees</a></div><div class="ttdeci">constexpr Angle degrees(float angle)</div><div class="ttdoc">Construct an angle value from a number of degrees.</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>Rotation angle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to <code>*this</code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#a92e1b0572a4703d9c23b01428f6494e3" title="Combine the current transform with a translation.">translate</a></code>, <code><a class="el" href="#ab0a14d89a99fe085164bdd083c88953a" title="Combine the current transform with a scaling.">scale</a></code> </dd></dl>

</div>
</div>
<a id="ace37c565cb78b73b9c5009e7842bcd73" name="ace37c565cb78b73b9c5009e7842bcd73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace37c565cb78b73b9c5009e7842bcd73">&#9670;&#160;</a></span>rotate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Transform.html">Transform</a> &amp; sf::Transform::rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1Angle.html">Angle</a></td>          <td class="paramname"><span class="paramname"><em>angle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a></td>          <td class="paramname"><span class="paramname"><em>center</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine the current transform with a rotation. </p>
<p>The center of rotation is provided for convenience as a second argument, so that you can build rotations around arbitrary points more easily (and efficiently) than the usual <code>translate(-center).rotate(angle).translate(center)</code>.</p>
<p>This function returns a reference to <code>*this</code>, so that calls can be chained. </p><div class="fragment"><div class="line"><a class="code hl_class" href="classsf_1_1Transform.html">sf::Transform</a> transform;</div>
<div class="line">transform.<a class="code hl_function" href="#a7172312b6e9aefce6a8cce4473363a69">rotate</a>(<a class="code hl_function" href="namespacesf.html#a956d8e2dd821777ce475c0856bfa879d">sf::degrees</a>(90), <a class="code hl_typedef" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">sf::Vector2f</a>(8, 3)).<a class="code hl_function" href="#a92e1b0572a4703d9c23b01428f6494e3">translate</a>(<a class="code hl_typedef" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">sf::Vector2f</a>(50, 20));</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>Rotation angle </td></tr>
    <tr><td class="paramname">center</td><td>Center of rotation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to <code>*this</code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#a92e1b0572a4703d9c23b01428f6494e3" title="Combine the current transform with a translation.">translate</a></code>, <code><a class="el" href="#ab0a14d89a99fe085164bdd083c88953a" title="Combine the current transform with a scaling.">scale</a></code> </dd></dl>

</div>
</div>
<a id="ab0a14d89a99fe085164bdd083c88953a" name="ab0a14d89a99fe085164bdd083c88953a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a14d89a99fe085164bdd083c88953a">&#9670;&#160;</a></span>scale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Transform.html">Transform</a> &amp; sf::Transform::scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a></td>          <td class="paramname"><span class="paramname"><em>factors</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combine the current transform with a scaling. </p>
<p>This function returns a reference to <code>*this</code>, so that calls can be chained. </p><div class="fragment"><div class="line"><a class="code hl_class" href="classsf_1_1Transform.html">sf::Transform</a> transform;</div>
<div class="line">transform.<a class="code hl_function" href="#ab0a14d89a99fe085164bdd083c88953a">scale</a>(<a class="code hl_typedef" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">sf::Vector2f</a>(2, 1)).<a class="code hl_function" href="#a7172312b6e9aefce6a8cce4473363a69">rotate</a>(<a class="code hl_function" href="namespacesf.html#a956d8e2dd821777ce475c0856bfa879d">sf::degrees</a>(45));</div>
<div class="ttc" id="aclasssf_1_1Transform_html_ab0a14d89a99fe085164bdd083c88953a"><div class="ttname"><a href="#ab0a14d89a99fe085164bdd083c88953a">sf::Transform::scale</a></div><div class="ttdeci">constexpr Transform &amp; scale(Vector2f factors)</div><div class="ttdoc">Combine the current transform with a scaling.</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factors</td><td>Scaling factors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to <code>*this</code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#a92e1b0572a4703d9c23b01428f6494e3" title="Combine the current transform with a translation.">translate</a></code>, <code><a class="el" href="#a7172312b6e9aefce6a8cce4473363a69" title="Combine the current transform with a rotation.">rotate</a></code> </dd></dl>

</div>
</div>
<a id="a6746da32321c7cfec595bfaff5243d0d" name="a6746da32321c7cfec595bfaff5243d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6746da32321c7cfec595bfaff5243d0d">&#9670;&#160;</a></span>scale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Transform.html">Transform</a> &amp; sf::Transform::scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a></td>          <td class="paramname"><span class="paramname"><em>factors</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a></td>          <td class="paramname"><span class="paramname"><em>center</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combine the current transform with a scaling. </p>
<p>The center of scaling is provided for convenience as a second argument, so that you can build scaling around arbitrary points more easily (and efficiently) than the usual <code>translate(-center).scale(factors).translate(center)</code>.</p>
<p>This function returns a reference to <code>*this</code>, so that calls can be chained. </p><div class="fragment"><div class="line"><a class="code hl_class" href="classsf_1_1Transform.html">sf::Transform</a> transform;</div>
<div class="line">transform.<a class="code hl_function" href="#ab0a14d89a99fe085164bdd083c88953a">scale</a>(<a class="code hl_typedef" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">sf::Vector2f</a>(2, 1), <a class="code hl_typedef" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">sf::Vector2f</a>(8, 3)).<a class="code hl_function" href="#a7172312b6e9aefce6a8cce4473363a69">rotate</a>(45);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factors</td><td>Scaling factors </td></tr>
    <tr><td class="paramname">center</td><td>Center of scaling</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to <code>*this</code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#a92e1b0572a4703d9c23b01428f6494e3" title="Combine the current transform with a translation.">translate</a></code>, <code><a class="el" href="#a7172312b6e9aefce6a8cce4473363a69" title="Combine the current transform with a rotation.">rotate</a></code> </dd></dl>

</div>
</div>
<a id="a64eb34f1465339dd28f801ad85f881d3" name="a64eb34f1465339dd28f801ad85f881d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64eb34f1465339dd28f801ad85f881d3">&#9670;&#160;</a></span>transformPoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a> sf::Transform::transformPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a></td>          <td class="paramname"><span class="paramname"><em>point</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classsf_1_1Transform.html" title="3x3 transform matrix">Transform</a> a 2D point. </p>
<p>These two statements are equivalent: </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">sf::Vector2f</a> transformedPoint = matrix.transformPoint(point);</div>
<div class="line"><a class="code hl_typedef" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">sf::Vector2f</a> transformedPoint = matrix * point;</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>Point to transform</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed point </dd></dl>

</div>
</div>
<a id="a7fc4d0e5221d792de5cbcafb44414887" name="a7fc4d0e5221d792de5cbcafb44414887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc4d0e5221d792de5cbcafb44414887">&#9670;&#160;</a></span>transformRect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesf.html#a701020eb396e62ba560619e68c689a38">FloatRect</a> sf::Transform::transformRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesf.html#a701020eb396e62ba560619e68c689a38">FloatRect</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rectangle</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classsf_1_1Transform.html" title="3x3 transform matrix">Transform</a> a rectangle. </p>
<p>Since SFML doesn't provide support for oriented rectangles, the result of this function is always an axis-aligned rectangle. Which means that if the transform contains a rotation, the bounding rectangle of the transformed rectangle is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rectangle</td><td>Rectangle to transform</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed rectangle </dd></dl>

</div>
</div>
<a id="a92e1b0572a4703d9c23b01428f6494e3" name="a92e1b0572a4703d9c23b01428f6494e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e1b0572a4703d9c23b01428f6494e3">&#9670;&#160;</a></span>translate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Transform.html">Transform</a> &amp; sf::Transform::translate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combine the current transform with a translation. </p>
<p>This function returns a reference to <code>*this</code>, so that calls can be chained. </p><div class="fragment"><div class="line"><a class="code hl_class" href="classsf_1_1Transform.html">sf::Transform</a> transform;</div>
<div class="line">transform.<a class="code hl_function" href="#a92e1b0572a4703d9c23b01428f6494e3">translate</a>(<a class="code hl_typedef" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">sf::Vector2f</a>(100, 200)).<a class="code hl_function" href="#a7172312b6e9aefce6a8cce4473363a69">rotate</a>(<a class="code hl_function" href="namespacesf.html#a956d8e2dd821777ce475c0856bfa879d">sf::degrees</a>(45));</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Translation offset to apply</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to <code>*this</code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#a7172312b6e9aefce6a8cce4473363a69" title="Combine the current transform with a rotation.">rotate</a></code>, <code><a class="el" href="#ab0a14d89a99fe085164bdd083c88953a" title="Combine the current transform with a scaling.">scale</a></code> </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a6cb4691413724c6d2b580c1615170dd2" name="a6cb4691413724c6d2b580c1615170dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb4691413724c6d2b580c1615170dd2">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Transform.html">Transform</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Transform.html">Transform</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>right</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel related">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of binary <code>operator!=</code> to compare two transforms. </p>
<p>This call is equivalent to <code>!(left == right)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>Left operand (the first transform) </td></tr>
    <tr><td class="paramname">right</td><td>Right operand (the second transform)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the transforms are not equal, <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="afe3eefbdbe67540f2f7468f7262edf62" name="afe3eefbdbe67540f2f7468f7262edf62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe3eefbdbe67540f2f7468f7262edf62">&#9670;&#160;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Transform.html">Transform</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Transform.html">Transform</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Transform.html">Transform</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>right</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel related">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of binary <code>operator*</code> to combine two transforms. </p>
<p>This call is equivalent to calling <code>Transform(left).combine(right)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>Left operand (the first transform) </td></tr>
    <tr><td class="paramname">right</td><td>Right operand (the second transform)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New combined transform </dd></dl>

</div>
</div>
<a id="a18b2481b28513108db3aca07dc77d3a3" name="a18b2481b28513108db3aca07dc77d3a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b2481b28513108db3aca07dc77d3a3">&#9670;&#160;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Transform.html">Transform</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a></td>          <td class="paramname"><span class="paramname"><em>right</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel related">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of binary <code>operator*</code> to transform a point. </p>
<p>This call is equivalent to calling <code>left.transformPoint(right)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>Left operand (the transform) </td></tr>
    <tr><td class="paramname">right</td><td>Right operand (the point to transform)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New transformed point </dd></dl>

</div>
</div>
<a id="a3aee0009a8c1675802c5d4565b592fd7" name="a3aee0009a8c1675802c5d4565b592fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aee0009a8c1675802c5d4565b592fd7">&#9670;&#160;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Transform.html">Transform</a> &amp; operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1Transform.html">Transform</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Transform.html">Transform</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>right</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel related">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of binary <code>operator*=</code> to combine two transforms. </p>
<p>This call is equivalent to calling <code>left.combine(right)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>Left operand (the first transform) </td></tr>
    <tr><td class="paramname">right</td><td>Right operand (the second transform)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The combined transform </dd></dl>

</div>
</div>
<a id="aa18d835d37f65fa22b703c243f83dc29" name="aa18d835d37f65fa22b703c243f83dc29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18d835d37f65fa22b703c243f83dc29">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Transform.html">Transform</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Transform.html">Transform</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>right</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel related">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of binary <code>operator==</code> to compare two transforms. </p>
<p>Performs an element-wise comparison of the elements of the left transform with the elements of the right transform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>Left operand (the first transform) </td></tr>
    <tr><td class="paramname">right</td><td>Right operand (the second transform)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the transforms are equal, <code>false</code> otherwise </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa4eb1eecbcb9979d76e2543b337fdb13" name="aa4eb1eecbcb9979d76e2543b337fdb13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4eb1eecbcb9979d76e2543b337fdb13">&#9670;&#160;</a></span>Identity</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsf_1_1Transform.html">Transform</a> sf::Transform::Identity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The identity transform (does nothing) </p>

<p class="definition">Definition at line <a class="el" href="Transform_8hpp_source.html#l00265">265</a> of file <a class="el" href="Transform_8hpp_source.html">Transform.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Transform_8hpp_source.html">Transform.hpp</a></li>
</ul>
</div><!-- contents -->
        </div>
        <div id="footer-container">
            <div id="footer">
                SFML is licensed under the terms and conditions of the <a href="https://www.sfml-dev.org/license.php">zlib/png license</a>.<br />
                Copyright &copy; Laurent Gomila &nbsp;::&nbsp;
                Documentation generated by <a href="http://www.doxygen.org/" title="doxygen website">doxygen</a> &nbsp;::&nbsp;
            </div>
        </div>
    </body>
</html>
