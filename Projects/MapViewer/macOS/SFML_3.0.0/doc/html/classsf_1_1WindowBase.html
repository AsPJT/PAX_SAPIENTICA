<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>SFML - Simple and Fast Multimedia Library</title>
        <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
        <link rel="stylesheet" type="text/css" href="doxygen.css" title="default" media="screen,print" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
        <script type="text/javascript" src="clipboard.js"></script>
        <script type="text/javascript" src="cookie.js"></script>
        <link rel="stylesheet" type="text/css" href="search/search.css" />
        <link rel="stylesheet" type="text/css" href="searchOverrides.css" />
        <script type="text/javascript" src="search/searchdata.js"></script>
        <script type="text/javascript" src="search/search.js"></script>
        <script type="text/javascript">
        /* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
          $(document).ready(function() { init_search(); });
        /* @license-end */
        </script>
    </head>
    <body>
        <div id="banner-container">
            <div id="banner">
                <span id="sfml">SFML 3.0.0</span>
            </div>
        </div>
        <div id="content">
            <div>
<!-- Generated by Doxygen 1.13.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="topics.html"><span>Topics</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesf.html">sf</a></li><li class="navelem"><a class="el" href="classsf_1_1WindowBase.html">WindowBase</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classsf_1_1WindowBase-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">sf::WindowBase Class Reference<div class="ingroups"><a class="el" href="group__window.html">Window module</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classsf_1_1Window.html" title="Window that serves as a target for OpenGL rendering.">Window</a> that serves as a base for other windows.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="WindowBase_8hpp_source.html">SFML/Window/WindowBase.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sf::WindowBase:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsf_1_1WindowBase.png" usemap="#sf::WindowBase_map" alt=""/>
  <map id="sf::WindowBase_map" name="sf::WindowBase_map">
<area href="classsf_1_1Window.html" title="Window that serves as a target for OpenGL rendering." alt="sf::Window" shape="rect" coords="0,56,113,80"/>
<area href="classsf_1_1RenderWindow.html" title="Window that can serve as a target for 2D drawing." alt="sf::RenderWindow" shape="rect" coords="0,112,113,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0cfe9d015cc95b89ef862c8d8050a964" id="r_a0cfe9d015cc95b89ef862c8d8050a964"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0cfe9d015cc95b89ef862c8d8050a964">WindowBase</a> ()</td></tr>
<tr class="memdesc:a0cfe9d015cc95b89ef862c8d8050a964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:a0cfe9d015cc95b89ef862c8d8050a964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae647a1d5fa690408320195af4bc48dee" id="r_ae647a1d5fa690408320195af4bc48dee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae647a1d5fa690408320195af4bc48dee">WindowBase</a> (<a class="el" href="classsf_1_1VideoMode.html">VideoMode</a> mode, const <a class="el" href="classsf_1_1String.html">String</a> &amp;title, std::uint32_t style=<a class="el" href="group__window.html#ggad18e393838b2fbef61886629b0c870bca5597cd420fc461807e4a201c92adea37">Style::Default</a>, <a class="el" href="group__window.html#ga504e2cd8fc6a852463f8d049db1151e5">State</a> state=<a class="el" href="group__window.html#gga504e2cd8fc6a852463f8d049db1151e5ab13311ab51c4c34757f67f26580018dd">State::Windowed</a>)</td></tr>
<tr class="memdesc:ae647a1d5fa690408320195af4bc48dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new window.  <br /></td></tr>
<tr class="separator:ae647a1d5fa690408320195af4bc48dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4541efb844ad853061fb3850a3ecfd45" id="r_a4541efb844ad853061fb3850a3ecfd45"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4541efb844ad853061fb3850a3ecfd45">WindowBase</a> (<a class="el" href="classsf_1_1VideoMode.html">VideoMode</a> mode, const <a class="el" href="classsf_1_1String.html">String</a> &amp;title, <a class="el" href="group__window.html#ga504e2cd8fc6a852463f8d049db1151e5">State</a> state)</td></tr>
<tr class="memdesc:a4541efb844ad853061fb3850a3ecfd45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new window.  <br /></td></tr>
<tr class="separator:a4541efb844ad853061fb3850a3ecfd45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e3667dddddfeda57d124de24f93ac1" id="r_ab4e3667dddddfeda57d124de24f93ac1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4e3667dddddfeda57d124de24f93ac1">WindowBase</a> (<a class="el" href="group__window.html#ga9858f04701033cd01859037d8dafd289">WindowHandle</a> handle)</td></tr>
<tr class="memdesc:ab4e3667dddddfeda57d124de24f93ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the window from an existing control.  <br /></td></tr>
<tr class="separator:ab4e3667dddddfeda57d124de24f93ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aac2a828b6bbd39b7195bb0545a2c47" id="r_a7aac2a828b6bbd39b7195bb0545a2c47"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7aac2a828b6bbd39b7195bb0545a2c47">~WindowBase</a> ()</td></tr>
<tr class="memdesc:a7aac2a828b6bbd39b7195bb0545a2c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a7aac2a828b6bbd39b7195bb0545a2c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ec1d96f6bc8b12af49d359d176410c" id="r_a50ec1d96f6bc8b12af49d359d176410c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50ec1d96f6bc8b12af49d359d176410c">WindowBase</a> (const <a class="el" href="classsf_1_1WindowBase.html">WindowBase</a> &amp;)=delete</td></tr>
<tr class="memdesc:a50ec1d96f6bc8b12af49d359d176410c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy constructor.  <br /></td></tr>
<tr class="separator:a50ec1d96f6bc8b12af49d359d176410c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afada06381eb41e6a0b027133ef875740" id="r_afada06381eb41e6a0b027133ef875740"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsf_1_1WindowBase.html">WindowBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afada06381eb41e6a0b027133ef875740">operator=</a> (const <a class="el" href="classsf_1_1WindowBase.html">WindowBase</a> &amp;)=delete</td></tr>
<tr class="memdesc:afada06381eb41e6a0b027133ef875740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy assignment.  <br /></td></tr>
<tr class="separator:afada06381eb41e6a0b027133ef875740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef508fa1812c97a3436723a2c6fdb1b4" id="r_aef508fa1812c97a3436723a2c6fdb1b4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef508fa1812c97a3436723a2c6fdb1b4">WindowBase</a> (<a class="el" href="classsf_1_1WindowBase.html">WindowBase</a> &amp;&amp;) noexcept</td></tr>
<tr class="memdesc:aef508fa1812c97a3436723a2c6fdb1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="separator:aef508fa1812c97a3436723a2c6fdb1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f9f0faf72adf9b53638061bae4d8b2" id="r_a58f9f0faf72adf9b53638061bae4d8b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsf_1_1WindowBase.html">WindowBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58f9f0faf72adf9b53638061bae4d8b2">operator=</a> (<a class="el" href="classsf_1_1WindowBase.html">WindowBase</a> &amp;&amp;) noexcept</td></tr>
<tr class="memdesc:a58f9f0faf72adf9b53638061bae4d8b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment.  <br /></td></tr>
<tr class="separator:a58f9f0faf72adf9b53638061bae4d8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612f5918f3cb042fcf1189fed24b91d4" id="r_a612f5918f3cb042fcf1189fed24b91d4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a612f5918f3cb042fcf1189fed24b91d4">create</a> (<a class="el" href="classsf_1_1VideoMode.html">VideoMode</a> mode, const <a class="el" href="classsf_1_1String.html">String</a> &amp;title, std::uint32_t style=<a class="el" href="group__window.html#ggad18e393838b2fbef61886629b0c870bca5597cd420fc461807e4a201c92adea37">Style::Default</a>, <a class="el" href="group__window.html#ga504e2cd8fc6a852463f8d049db1151e5">State</a> state=<a class="el" href="group__window.html#gga504e2cd8fc6a852463f8d049db1151e5ab13311ab51c4c34757f67f26580018dd">State::Windowed</a>)</td></tr>
<tr class="memdesc:a612f5918f3cb042fcf1189fed24b91d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create (or recreate) the window.  <br /></td></tr>
<tr class="separator:a612f5918f3cb042fcf1189fed24b91d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1730d462059617d78f08c0e4eeee771a" id="r_a1730d462059617d78f08c0e4eeee771a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1730d462059617d78f08c0e4eeee771a">create</a> (<a class="el" href="classsf_1_1VideoMode.html">VideoMode</a> mode, const <a class="el" href="classsf_1_1String.html">String</a> &amp;title, <a class="el" href="group__window.html#ga504e2cd8fc6a852463f8d049db1151e5">State</a> state)</td></tr>
<tr class="memdesc:a1730d462059617d78f08c0e4eeee771a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create (or recreate) the window.  <br /></td></tr>
<tr class="separator:a1730d462059617d78f08c0e4eeee771a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4968e15e33fd70629983f635bcc21c" id="r_a4e4968e15e33fd70629983f635bcc21c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e4968e15e33fd70629983f635bcc21c">create</a> (<a class="el" href="group__window.html#ga9858f04701033cd01859037d8dafd289">WindowHandle</a> handle)</td></tr>
<tr class="memdesc:a4e4968e15e33fd70629983f635bcc21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create (or recreate) the window from an existing control.  <br /></td></tr>
<tr class="separator:a4e4968e15e33fd70629983f635bcc21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5ea0ba0ab584dbd11bbfea233b457f" id="r_a9a5ea0ba0ab584dbd11bbfea233b457f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a5ea0ba0ab584dbd11bbfea233b457f">close</a> ()</td></tr>
<tr class="memdesc:a9a5ea0ba0ab584dbd11bbfea233b457f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the window and destroy all the attached resources.  <br /></td></tr>
<tr class="separator:a9a5ea0ba0ab584dbd11bbfea233b457f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43559822564ef958dc664a90c57cba0" id="r_aa43559822564ef958dc664a90c57cba0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa43559822564ef958dc664a90c57cba0">isOpen</a> () const</td></tr>
<tr class="memdesc:aa43559822564ef958dc664a90c57cba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell whether or not the window is open.  <br /></td></tr>
<tr class="separator:aa43559822564ef958dc664a90c57cba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6090926b477e9d0a83854b94b9e1fd35" id="r_a6090926b477e9d0a83854b94b9e1fd35"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classsf_1_1Event.html">Event</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6090926b477e9d0a83854b94b9e1fd35">pollEvent</a> ()</td></tr>
<tr class="memdesc:a6090926b477e9d0a83854b94b9e1fd35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the next event from the front of the FIFO event queue, if any, and return it.  <br /></td></tr>
<tr class="separator:a6090926b477e9d0a83854b94b9e1fd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5975f6f6a06ecd6c18fa0f62cd1edf7" id="r_ab5975f6f6a06ecd6c18fa0f62cd1edf7"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classsf_1_1Event.html">Event</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5975f6f6a06ecd6c18fa0f62cd1edf7">waitEvent</a> (<a class="el" href="classsf_1_1Time.html">Time</a> timeout=<a class="el" href="classsf_1_1Time.html#a8db127b632fa8da21550e7282af11fa0">Time::Zero</a>)</td></tr>
<tr class="memdesc:ab5975f6f6a06ecd6c18fa0f62cd1edf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for an event and return it.  <br /></td></tr>
<tr class="separator:ab5975f6f6a06ecd6c18fa0f62cd1edf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86ae79ff4e2da25af1ca3cd06f79557" id="r_ad86ae79ff4e2da25af1ca3cd06f79557"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ad86ae79ff4e2da25af1ca3cd06f79557"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad86ae79ff4e2da25af1ca3cd06f79557">handleEvents</a> (Ts &amp;&amp;... handlers)</td></tr>
<tr class="memdesc:ad86ae79ff4e2da25af1ca3cd06f79557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle all pending events.  <br /></td></tr>
<tr class="separator:ad86ae79ff4e2da25af1ca3cd06f79557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ddaa5943f547645079f081422e45c81" id="r_a5ddaa5943f547645079f081422e45c81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesf.html#af0ffe1b157a56931ee3a9a1a771a827a">Vector2i</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ddaa5943f547645079f081422e45c81">getPosition</a> () const</td></tr>
<tr class="memdesc:a5ddaa5943f547645079f081422e45c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the position of the window.  <br /></td></tr>
<tr class="separator:a5ddaa5943f547645079f081422e45c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7282bbf43820f20f41c704c2ab5b86f8" id="r_a7282bbf43820f20f41c704c2ab5b86f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7282bbf43820f20f41c704c2ab5b86f8">setPosition</a> (<a class="el" href="namespacesf.html#af0ffe1b157a56931ee3a9a1a771a827a">Vector2i</a> position)</td></tr>
<tr class="memdesc:a7282bbf43820f20f41c704c2ab5b86f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the position of the window on screen.  <br /></td></tr>
<tr class="separator:a7282bbf43820f20f41c704c2ab5b86f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188a482d916a972d59d6b0700132e379" id="r_a188a482d916a972d59d6b0700132e379"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesf.html#adc674b5f5c13a6734954a18e01a73b42">Vector2u</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a188a482d916a972d59d6b0700132e379">getSize</a> () const</td></tr>
<tr class="memdesc:a188a482d916a972d59d6b0700132e379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the rendering region of the window.  <br /></td></tr>
<tr class="separator:a188a482d916a972d59d6b0700132e379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd2581f59f35bd379307ea5b6254631c" id="r_abd2581f59f35bd379307ea5b6254631c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd2581f59f35bd379307ea5b6254631c">setSize</a> (<a class="el" href="namespacesf.html#adc674b5f5c13a6734954a18e01a73b42">Vector2u</a> size)</td></tr>
<tr class="memdesc:abd2581f59f35bd379307ea5b6254631c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the size of the rendering region of the window.  <br /></td></tr>
<tr class="separator:abd2581f59f35bd379307ea5b6254631c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742a8f386668f58fe27c0b5f5929de7e" id="r_a742a8f386668f58fe27c0b5f5929de7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a742a8f386668f58fe27c0b5f5929de7e">setMinimumSize</a> (const std::optional&lt; <a class="el" href="namespacesf.html#adc674b5f5c13a6734954a18e01a73b42">Vector2u</a> &gt; &amp;minimumSize)</td></tr>
<tr class="memdesc:a742a8f386668f58fe27c0b5f5929de7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minimum window rendering region size.  <br /></td></tr>
<tr class="separator:a742a8f386668f58fe27c0b5f5929de7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f856835295a85a2959c962a1616cad" id="r_a65f856835295a85a2959c962a1616cad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65f856835295a85a2959c962a1616cad">setMaximumSize</a> (const std::optional&lt; <a class="el" href="namespacesf.html#adc674b5f5c13a6734954a18e01a73b42">Vector2u</a> &gt; &amp;maximumSize)</td></tr>
<tr class="memdesc:a65f856835295a85a2959c962a1616cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum window rendering region size.  <br /></td></tr>
<tr class="separator:a65f856835295a85a2959c962a1616cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd36ae6244ae1e6d643f6c109e983f8" id="r_accd36ae6244ae1e6d643f6c109e983f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accd36ae6244ae1e6d643f6c109e983f8">setTitle</a> (const <a class="el" href="classsf_1_1String.html">String</a> &amp;title)</td></tr>
<tr class="memdesc:accd36ae6244ae1e6d643f6c109e983f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the title of the window.  <br /></td></tr>
<tr class="separator:accd36ae6244ae1e6d643f6c109e983f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ab1f9f9dc2312ad0ee83d1ffee9715" id="r_a07ab1f9f9dc2312ad0ee83d1ffee9715"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07ab1f9f9dc2312ad0ee83d1ffee9715">setIcon</a> (<a class="el" href="namespacesf.html#adc674b5f5c13a6734954a18e01a73b42">Vector2u</a> size, const std::uint8_t *pixels)</td></tr>
<tr class="memdesc:a07ab1f9f9dc2312ad0ee83d1ffee9715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the window's icon.  <br /></td></tr>
<tr class="separator:a07ab1f9f9dc2312ad0ee83d1ffee9715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576488ad202cb2cd4359af94eaba4dd8" id="r_a576488ad202cb2cd4359af94eaba4dd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a576488ad202cb2cd4359af94eaba4dd8">setVisible</a> (bool visible)</td></tr>
<tr class="memdesc:a576488ad202cb2cd4359af94eaba4dd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Show or hide the window.  <br /></td></tr>
<tr class="separator:a576488ad202cb2cd4359af94eaba4dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4a3372b2870294d1579d8621fe3c1a" id="r_afa4a3372b2870294d1579d8621fe3c1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa4a3372b2870294d1579d8621fe3c1a">setMouseCursorVisible</a> (bool visible)</td></tr>
<tr class="memdesc:afa4a3372b2870294d1579d8621fe3c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Show or hide the mouse cursor.  <br /></td></tr>
<tr class="separator:afa4a3372b2870294d1579d8621fe3c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0023344922a1e854175c8ca22b072020" id="r_a0023344922a1e854175c8ca22b072020"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0023344922a1e854175c8ca22b072020">setMouseCursorGrabbed</a> (bool grabbed)</td></tr>
<tr class="memdesc:a0023344922a1e854175c8ca22b072020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grab or release the mouse cursor.  <br /></td></tr>
<tr class="separator:a0023344922a1e854175c8ca22b072020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07487a3c7e04472b19e96d3a602213ec" id="r_a07487a3c7e04472b19e96d3a602213ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07487a3c7e04472b19e96d3a602213ec">setMouseCursor</a> (const <a class="el" href="classsf_1_1Cursor.html">Cursor</a> &amp;cursor)</td></tr>
<tr class="memdesc:a07487a3c7e04472b19e96d3a602213ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the displayed cursor to a native system cursor.  <br /></td></tr>
<tr class="separator:a07487a3c7e04472b19e96d3a602213ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1199a64d459ba531deb65f093050a6" id="r_afd1199a64d459ba531deb65f093050a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd1199a64d459ba531deb65f093050a6">setKeyRepeatEnabled</a> (bool enabled)</td></tr>
<tr class="memdesc:afd1199a64d459ba531deb65f093050a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable automatic key-repeat.  <br /></td></tr>
<tr class="separator:afd1199a64d459ba531deb65f093050a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37f939b492c7ea046d4f7b45ac46df1" id="r_ad37f939b492c7ea046d4f7b45ac46df1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad37f939b492c7ea046d4f7b45ac46df1">setJoystickThreshold</a> (float threshold)</td></tr>
<tr class="memdesc:ad37f939b492c7ea046d4f7b45ac46df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the joystick threshold.  <br /></td></tr>
<tr class="separator:ad37f939b492c7ea046d4f7b45ac46df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448770d2372d8df0a1ad6b1c7cce3c89" id="r_a448770d2372d8df0a1ad6b1c7cce3c89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a448770d2372d8df0a1ad6b1c7cce3c89">requestFocus</a> ()</td></tr>
<tr class="memdesc:a448770d2372d8df0a1ad6b1c7cce3c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request the current window to be made the active foreground window.  <br /></td></tr>
<tr class="separator:a448770d2372d8df0a1ad6b1c7cce3c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87bd19e979c426cb819ccde8c95232e" id="r_ad87bd19e979c426cb819ccde8c95232e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad87bd19e979c426cb819ccde8c95232e">hasFocus</a> () const</td></tr>
<tr class="memdesc:ad87bd19e979c426cb819ccde8c95232e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the window has the input focus.  <br /></td></tr>
<tr class="separator:ad87bd19e979c426cb819ccde8c95232e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af360bb48167c6db4d13e47d23d9c35da" id="r_af360bb48167c6db4d13e47d23d9c35da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__window.html#ga9858f04701033cd01859037d8dafd289">WindowHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af360bb48167c6db4d13e47d23d9c35da">getNativeHandle</a> () const</td></tr>
<tr class="memdesc:af360bb48167c6db4d13e47d23d9c35da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the OS-specific handle of the window.  <br /></td></tr>
<tr class="separator:af360bb48167c6db4d13e47d23d9c35da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1401a44aa18cff4c23184f909aae82df" id="r_a1401a44aa18cff4c23184f909aae82df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1401a44aa18cff4c23184f909aae82df">createVulkanSurface</a> (const <a class="el" href="Vulkan_8hpp.html#a09bfb88ab06300f8c5448e7bc53acd9b">VkInstance</a> &amp;instance, <a class="el" href="Vulkan_8hpp.html#a103b6ae069efe31b9adef4ce0b6b6273">VkSurfaceKHR</a> &amp;surface, const VkAllocationCallbacks *allocator=nullptr)</td></tr>
<tr class="memdesc:a1401a44aa18cff4c23184f909aae82df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="namespacesf_1_1Vulkan.html" title="Vulkan helper functions.">Vulkan</a> rendering surface.  <br /></td></tr>
<tr class="separator:a1401a44aa18cff4c23184f909aae82df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a3397a7265f654be7ce9ccde3a53a39df" id="r_a3397a7265f654be7ce9ccde3a53a39df"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3397a7265f654be7ce9ccde3a53a39df">onCreate</a> ()</td></tr>
<tr class="memdesc:a3397a7265f654be7ce9ccde3a53a39df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function called after the window has been created.  <br /></td></tr>
<tr class="separator:a3397a7265f654be7ce9ccde3a53a39df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be41815cbeb89bc49e8752b62283192" id="r_a8be41815cbeb89bc49e8752b62283192"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8be41815cbeb89bc49e8752b62283192">onResize</a> ()</td></tr>
<tr class="memdesc:a8be41815cbeb89bc49e8752b62283192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function called after the window has been resized.  <br /></td></tr>
<tr class="separator:a8be41815cbeb89bc49e8752b62283192"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a553f958a25683445088050a69d3de8e9" id="r_a553f958a25683445088050a69d3de8e9"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a553f958a25683445088050a69d3de8e9">Window</a></td></tr>
<tr class="separator:a553f958a25683445088050a69d3de8e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classsf_1_1Window.html" title="Window that serves as a target for OpenGL rendering.">Window</a> that serves as a base for other windows. </p>
<p><code><a class="el" href="classsf_1_1WindowBase.html" title="Window that serves as a base for other windows.">sf::WindowBase</a></code> serves as the base class for all Windows.</p>
<p>A <code><a class="el" href="classsf_1_1WindowBase.html" title="Window that serves as a base for other windows.">sf::WindowBase</a></code> can create its own new window, or be embedded into an already existing control using the <code>create(handle)</code> function.</p>
<p>The <code><a class="el" href="classsf_1_1WindowBase.html" title="Window that serves as a base for other windows.">sf::WindowBase</a></code> class provides a simple interface for manipulating the window: move, resize, show/hide, control mouse cursor, etc. It also provides event handling through its <code><a class="el" href="#a6090926b477e9d0a83854b94b9e1fd35" title="Pop the next event from the front of the FIFO event queue, if any, and return it.">pollEvent()</a></code> and <code><a class="el" href="#ab5975f6f6a06ecd6c18fa0f62cd1edf7" title="Wait for an event and return it.">waitEvent()</a></code> functions.</p>
<p>Usage example: </p><div class="fragment"><div class="line"><span class="comment">// Declare and create a new window</span></div>
<div class="line"><a class="code hl_class" href="classsf_1_1WindowBase.html">sf::WindowBase</a> window(<a class="code hl_class" href="classsf_1_1VideoMode.html">sf::VideoMode</a>({800, 600}), <span class="stringliteral">&quot;SFML window&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The main loop - ends as soon as the window is closed</span></div>
<div class="line"><span class="keywordflow">while</span> (window.<a class="code hl_function" href="#aa43559822564ef958dc664a90c57cba0">isOpen</a>())</div>
<div class="line">{</div>
<div class="line">   <span class="comment">// Event processing</span></div>
<div class="line">   <span class="keywordflow">while</span> (<span class="keyword">const</span> std::optional event = window.<a class="code hl_function" href="#a6090926b477e9d0a83854b94b9e1fd35">pollEvent</a>())</div>
<div class="line">   {</div>
<div class="line">       <span class="comment">// Request for closing the window</span></div>
<div class="line">       <span class="keywordflow">if</span> (event-&gt;is&lt;<a class="code hl_struct" href="structsf_1_1Event_1_1Closed.html">sf::Event::Closed</a>&gt;())</div>
<div class="line">           window.<a class="code hl_function" href="#a9a5ea0ba0ab584dbd11bbfea233b457f">close</a>();</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Do things with the window here...</span></div>
<div class="line">}</div>
<div class="ttc" id="aclasssf_1_1VideoMode_html"><div class="ttname"><a href="classsf_1_1VideoMode.html">sf::VideoMode</a></div><div class="ttdoc">VideoMode defines a video mode (size, bpp)</div><div class="ttdef"><b>Definition</b> <a href="VideoMode_8hpp_source.html#l00043">VideoMode.hpp:44</a></div></div>
<div class="ttc" id="aclasssf_1_1WindowBase_html"><div class="ttname"><a href="classsf_1_1WindowBase.html">sf::WindowBase</a></div><div class="ttdoc">Window that serves as a base for other windows.</div><div class="ttdef"><b>Definition</b> <a href="WindowBase_8hpp_source.html#l00062">WindowBase.hpp:63</a></div></div>
<div class="ttc" id="aclasssf_1_1WindowBase_html_a6090926b477e9d0a83854b94b9e1fd35"><div class="ttname"><a href="#a6090926b477e9d0a83854b94b9e1fd35">sf::WindowBase::pollEvent</a></div><div class="ttdeci">std::optional&lt; Event &gt; pollEvent()</div><div class="ttdoc">Pop the next event from the front of the FIFO event queue, if any, and return it.</div></div>
<div class="ttc" id="aclasssf_1_1WindowBase_html_a9a5ea0ba0ab584dbd11bbfea233b457f"><div class="ttname"><a href="#a9a5ea0ba0ab584dbd11bbfea233b457f">sf::WindowBase::close</a></div><div class="ttdeci">virtual void close()</div><div class="ttdoc">Close the window and destroy all the attached resources.</div></div>
<div class="ttc" id="aclasssf_1_1WindowBase_html_aa43559822564ef958dc664a90c57cba0"><div class="ttname"><a href="#aa43559822564ef958dc664a90c57cba0">sf::WindowBase::isOpen</a></div><div class="ttdeci">bool isOpen() const</div><div class="ttdoc">Tell whether or not the window is open.</div></div>
<div class="ttc" id="astructsf_1_1Event_1_1Closed_html"><div class="ttname"><a href="structsf_1_1Event_1_1Closed.html">sf::Event::Closed</a></div><div class="ttdoc">Closed event subtype.</div><div class="ttdef"><b>Definition</b> <a href="Event_8hpp_source.html#l00053">Event.hpp:54</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="WindowBase_8hpp_source.html#l00062">62</a> of file <a class="el" href="WindowBase_8hpp_source.html">WindowBase.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0cfe9d015cc95b89ef862c8d8050a964" name="a0cfe9d015cc95b89ef862c8d8050a964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cfe9d015cc95b89ef862c8d8050a964">&#9670;&#160;</a></span>WindowBase() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sf::WindowBase::WindowBase </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>This constructor doesn't actually create the window, use the other constructors or call <code><a class="el" href="#a612f5918f3cb042fcf1189fed24b91d4" title="Create (or recreate) the window.">create()</a></code> to do so. </p>

</div>
</div>
<a id="ae647a1d5fa690408320195af4bc48dee" name="ae647a1d5fa690408320195af4bc48dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae647a1d5fa690408320195af4bc48dee">&#9670;&#160;</a></span>WindowBase() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sf::WindowBase::WindowBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1VideoMode.html">VideoMode</a></td>          <td class="paramname"><span class="paramname"><em>mode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsf_1_1String.html">String</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>title</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t</td>          <td class="paramname"><span class="paramname"><em>style</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__window.html#ggad18e393838b2fbef61886629b0c870bca5597cd420fc461807e4a201c92adea37">Style::Default</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__window.html#ga504e2cd8fc6a852463f8d049db1151e5">State</a></td>          <td class="paramname"><span class="paramname"><em>state</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__window.html#gga504e2cd8fc6a852463f8d049db1151e5ab13311ab51c4c34757f67f26580018dd">State::Windowed</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new window. </p>
<p>This constructor creates the window with the size and pixel depth defined in <code>mode</code>. An optional style can be passed to customize the look and behavior of the window (borders, title bar, resizable, closable, ...). An optional state can be provided. If <code>state</code> is <code><a class="el" href="group__window.html#gga504e2cd8fc6a852463f8d049db1151e5a0829ea6734059d66e6bf87096b215dc1" title="Fullscreen window.">State::Fullscreen</a></code>, then <code>mode</code> must be a valid video mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Video mode to use (defines the width, height and depth of the rendering area of the window) </td></tr>
    <tr><td class="paramname">title</td><td>Title of the window </td></tr>
    <tr><td class="paramname">style</td><td>Window style, a bitwise OR combination of <code><a class="el" href="namespacesf_1_1Style.html">sf::Style</a></code> enumerators </td></tr>
    <tr><td class="paramname">state</td><td>Window state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4541efb844ad853061fb3850a3ecfd45" name="a4541efb844ad853061fb3850a3ecfd45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4541efb844ad853061fb3850a3ecfd45">&#9670;&#160;</a></span>WindowBase() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sf::WindowBase::WindowBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1VideoMode.html">VideoMode</a></td>          <td class="paramname"><span class="paramname"><em>mode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsf_1_1String.html">String</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>title</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__window.html#ga504e2cd8fc6a852463f8d049db1151e5">State</a></td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new window. </p>
<p>This constructor creates the window with the size and pixel depth defined in <code>mode</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Video mode to use (defines the width, height and depth of the rendering area of the window) </td></tr>
    <tr><td class="paramname">title</td><td>Title of the window </td></tr>
    <tr><td class="paramname">state</td><td>Window state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4e3667dddddfeda57d124de24f93ac1" name="ab4e3667dddddfeda57d124de24f93ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e3667dddddfeda57d124de24f93ac1">&#9670;&#160;</a></span>WindowBase() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sf::WindowBase::WindowBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__window.html#ga9858f04701033cd01859037d8dafd289">WindowHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the window from an existing control. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Platform-specific handle of the control </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7aac2a828b6bbd39b7195bb0545a2c47" name="a7aac2a828b6bbd39b7195bb0545a2c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aac2a828b6bbd39b7195bb0545a2c47">&#9670;&#160;</a></span>~WindowBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual sf::WindowBase::~WindowBase </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Closes the window and frees all the resources attached to it. </p>

</div>
</div>
<a id="a50ec1d96f6bc8b12af49d359d176410c" name="a50ec1d96f6bc8b12af49d359d176410c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ec1d96f6bc8b12af49d359d176410c">&#9670;&#160;</a></span>WindowBase() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sf::WindowBase::WindowBase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1WindowBase.html">WindowBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy constructor. </p>

</div>
</div>
<a id="aef508fa1812c97a3436723a2c6fdb1b4" name="aef508fa1812c97a3436723a2c6fdb1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef508fa1812c97a3436723a2c6fdb1b4">&#9670;&#160;</a></span>WindowBase() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sf::WindowBase::WindowBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1WindowBase.html">WindowBase</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9a5ea0ba0ab584dbd11bbfea233b457f" name="a9a5ea0ba0ab584dbd11bbfea233b457f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a5ea0ba0ab584dbd11bbfea233b457f">&#9670;&#160;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sf::WindowBase::close </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the window and destroy all the attached resources. </p>
<p>After calling this function, the <code><a class="el" href="classsf_1_1Window.html" title="Window that serves as a target for OpenGL rendering.">sf::Window</a></code> instance remains valid and you can call <code><a class="el" href="#a612f5918f3cb042fcf1189fed24b91d4" title="Create (or recreate) the window.">create()</a></code> to recreate the window. All other functions such as <code><a class="el" href="#a6090926b477e9d0a83854b94b9e1fd35" title="Pop the next event from the front of the FIFO event queue, if any, and return it.">pollEvent()</a></code> or <code>display()</code> will still work (i.e. you don't have to test <code><a class="el" href="#aa43559822564ef958dc664a90c57cba0" title="Tell whether or not the window is open.">isOpen()</a></code> every time), and will have no effect on closed windows. </p>

<p>Reimplemented in <a class="el" href="classsf_1_1Window.html#ab1d808a3682db8d113d67354bcbd717d">sf::Window</a>.</p>

</div>
</div>
<a id="a1730d462059617d78f08c0e4eeee771a" name="a1730d462059617d78f08c0e4eeee771a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1730d462059617d78f08c0e4eeee771a">&#9670;&#160;</a></span>create() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sf::WindowBase::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1VideoMode.html">VideoMode</a></td>          <td class="paramname"><span class="paramname"><em>mode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsf_1_1String.html">String</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>title</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__window.html#ga504e2cd8fc6a852463f8d049db1151e5">State</a></td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create (or recreate) the window. </p>
<p>If the window was already created, it closes it first. If <code>state</code> is <code><a class="el" href="group__window.html#gga504e2cd8fc6a852463f8d049db1151e5a0829ea6734059d66e6bf87096b215dc1" title="Fullscreen window.">State::Fullscreen</a></code>, then <code>mode</code> must be a valid video mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Video mode to use (defines the width, height and depth of the rendering area of the window) </td></tr>
    <tr><td class="paramname">title</td><td>Title of the window </td></tr>
    <tr><td class="paramname">state</td><td>Window state </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classsf_1_1Window.html#a17af5e75b858635f45ad46ce91668ce8">sf::Window</a>.</p>

</div>
</div>
<a id="a612f5918f3cb042fcf1189fed24b91d4" name="a612f5918f3cb042fcf1189fed24b91d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a612f5918f3cb042fcf1189fed24b91d4">&#9670;&#160;</a></span>create() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sf::WindowBase::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1VideoMode.html">VideoMode</a></td>          <td class="paramname"><span class="paramname"><em>mode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsf_1_1String.html">String</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>title</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t</td>          <td class="paramname"><span class="paramname"><em>style</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__window.html#ggad18e393838b2fbef61886629b0c870bca5597cd420fc461807e4a201c92adea37">Style::Default</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__window.html#ga504e2cd8fc6a852463f8d049db1151e5">State</a></td>          <td class="paramname"><span class="paramname"><em>state</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__window.html#gga504e2cd8fc6a852463f8d049db1151e5ab13311ab51c4c34757f67f26580018dd">State::Windowed</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create (or recreate) the window. </p>
<p>If the window was already created, it closes it first. If <code>state</code> is <code><a class="el" href="group__window.html#gga504e2cd8fc6a852463f8d049db1151e5a0829ea6734059d66e6bf87096b215dc1" title="Fullscreen window.">State::Fullscreen</a></code>, then <code>mode</code> must be a valid video mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Video mode to use (defines the width, height and depth of the rendering area of the window) </td></tr>
    <tr><td class="paramname">title</td><td>Title of the window </td></tr>
    <tr><td class="paramname">style</td><td>Window style, a bitwise OR combination of <code><a class="el" href="namespacesf_1_1Style.html">sf::Style</a></code> enumerators </td></tr>
    <tr><td class="paramname">state</td><td>Window state </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classsf_1_1Window.html#ae77f112046c240b477963326e2363e18">sf::Window</a>.</p>

</div>
</div>
<a id="a4e4968e15e33fd70629983f635bcc21c" name="a4e4968e15e33fd70629983f635bcc21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e4968e15e33fd70629983f635bcc21c">&#9670;&#160;</a></span>create() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sf::WindowBase::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__window.html#ga9858f04701033cd01859037d8dafd289">WindowHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create (or recreate) the window from an existing control. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Platform-specific handle of the control </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classsf_1_1Window.html#a5246d47ddea8ad787be150e09df1fc53">sf::Window</a>.</p>

</div>
</div>
<a id="a1401a44aa18cff4c23184f909aae82df" name="a1401a44aa18cff4c23184f909aae82df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1401a44aa18cff4c23184f909aae82df">&#9670;&#160;</a></span>createVulkanSurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sf::WindowBase::createVulkanSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="Vulkan_8hpp.html#a09bfb88ab06300f8c5448e7bc53acd9b">VkInstance</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Vulkan_8hpp.html#a103b6ae069efe31b9adef4ce0b6b6273">VkSurfaceKHR</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>surface</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkAllocationCallbacks *</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="namespacesf_1_1Vulkan.html" title="Vulkan helper functions.">Vulkan</a> rendering surface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td><a class="el" href="namespacesf_1_1Vulkan.html" title="Vulkan helper functions.">Vulkan</a> instance </td></tr>
    <tr><td class="paramname">surface</td><td>Created surface </td></tr>
    <tr><td class="paramname">allocator</td><td>Allocator to use</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if surface creation was successful, <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="af360bb48167c6db4d13e47d23d9c35da" name="af360bb48167c6db4d13e47d23d9c35da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af360bb48167c6db4d13e47d23d9c35da">&#9670;&#160;</a></span>getNativeHandle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__window.html#ga9858f04701033cd01859037d8dafd289">WindowHandle</a> sf::WindowBase::getNativeHandle </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the OS-specific handle of the window. </p>
<p>The type of the returned handle is <code><a class="el" href="group__window.html#ga9858f04701033cd01859037d8dafd289" title="Low-level window handle type, specific to each platform.">sf::WindowHandle</a></code>, which is a type alias to the handle type defined by the OS. You shouldn't need to use this function, unless you have very specific stuff to implement that SFML doesn't support, or implement a temporary workaround until a bug is fixed.</p>
<dl class="section return"><dt>Returns</dt><dd>System handle of the window </dd></dl>

</div>
</div>
<a id="a5ddaa5943f547645079f081422e45c81" name="a5ddaa5943f547645079f081422e45c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ddaa5943f547645079f081422e45c81">&#9670;&#160;</a></span>getPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesf.html#af0ffe1b157a56931ee3a9a1a771a827a">Vector2i</a> sf::WindowBase::getPosition </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the position of the window. </p>
<dl class="section return"><dt>Returns</dt><dd>Position of the window, in pixels</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#a7282bbf43820f20f41c704c2ab5b86f8" title="Change the position of the window on screen.">setPosition</a></code> </dd></dl>

</div>
</div>
<a id="a188a482d916a972d59d6b0700132e379" name="a188a482d916a972d59d6b0700132e379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188a482d916a972d59d6b0700132e379">&#9670;&#160;</a></span>getSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesf.html#adc674b5f5c13a6734954a18e01a73b42">Vector2u</a> sf::WindowBase::getSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the rendering region of the window. </p>
<p>The size doesn't include the titlebar and borders of the window.</p>
<dl class="section return"><dt>Returns</dt><dd>Size in pixels</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#abd2581f59f35bd379307ea5b6254631c" title="Change the size of the rendering region of the window.">setSize</a></code> </dd></dl>

</div>
</div>
<a id="ad86ae79ff4e2da25af1ca3cd06f79557" name="ad86ae79ff4e2da25af1ca3cd06f79557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86ae79ff4e2da25af1ca3cd06f79557">&#9670;&#160;</a></span>handleEvents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sf::WindowBase::handleEvents </td>
          <td>(</td>
          <td class="paramtype">Ts &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>handlers</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle all pending events. </p>
<p>This function is not blocking: if there's no pending event then it will return without calling any of the handlers.</p>
<p>This function can take a variadic list of event handlers that each take a concrete event type as a single parameter. The event handlers can be any kind of callable object that has an <code>operator()</code> defined for a specific event type. Additionally a generic callable can also be provided that will be invoked for every event type. If both types of callables are provided, the callables taking concrete event types will be preferred over the generic callable by overload resolution. Generic callables can be used to customize handler dispatching based on the deduced type of the event and other information available at compile time.</p>
<p>Examples of callables:</p><ul>
<li>Lambda expressions: <code>[&amp;](const <a class="el" href="structsf_1_1Event_1_1KeyPressed.html" title="Key pressed event subtype.">sf::Event::KeyPressed</a>) { ... }</code></li>
<li>Free functions: <code>void handler(const <a class="el" href="structsf_1_1Event_1_1KeyPressed.html" title="Key pressed event subtype.">sf::Event::KeyPressed</a>&amp;) { ... }</code></li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Only provide handlers for concrete event types</span></div>
<div class="line">window.handleEvents(</div>
<div class="line">    [&amp;](<span class="keyword">const</span> <a class="code hl_struct" href="structsf_1_1Event_1_1Closed.html">sf::Event::Closed</a>&amp;) { <span class="comment">/* handle event */</span> },</div>
<div class="line">    [&amp;](<span class="keyword">const</span> <a class="code hl_struct" href="structsf_1_1Event_1_1KeyPressed.html">sf::Event::KeyPressed</a>&amp; keyPress) { <span class="comment">/* handle event */</span> }</div>
<div class="line">);</div>
<div class="ttc" id="astructsf_1_1Event_1_1KeyPressed_html"><div class="ttname"><a href="structsf_1_1Event_1_1KeyPressed.html">sf::Event::KeyPressed</a></div><div class="ttdoc">Key pressed event subtype.</div><div class="ttdef"><b>Definition</b> <a href="Event_8hpp_source.html#l00095">Event.hpp:96</a></div></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">// Provide a generic event handler</span></div>
<div class="line">window.handleEvents(</div>
<div class="line">    [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; event)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::is_same_v&lt;std::decay_t&lt;<span class="keyword">decltype</span>(event)&gt;, <a class="code hl_struct" href="structsf_1_1Event_1_1Closed.html">sf::Event::Closed</a>&gt;)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Handle Closed</span></div>
<div class="line">            handleClosed();</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::is_same_v&lt;std::decay_t&lt;<span class="keyword">decltype</span>(event)&gt;, <a class="code hl_struct" href="structsf_1_1Event_1_1KeyPressed.html">sf::Event::KeyPressed</a>&gt;)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Handle KeyPressed</span></div>
<div class="line">            handleKeyPressed(event);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Handle non-KeyPressed</span></div>
<div class="line">            handleOtherEvents(event);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">);</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">// Provide handlers for concrete types and fall back to generic handler</span></div>
<div class="line">window.handleEvents(</div>
<div class="line">    [&amp;](<span class="keyword">const</span> <a class="code hl_struct" href="structsf_1_1Event_1_1Closed.html">sf::Event::Closed</a>&amp;) { <span class="comment">/* handle event */</span> },</div>
<div class="line">    [&amp;](<span class="keyword">const</span> <a class="code hl_struct" href="structsf_1_1Event_1_1KeyPressed.html">sf::Event::KeyPressed</a>&amp; keyPress) { <span class="comment">/* handle event */</span> },</div>
<div class="line">    [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; event) { <span class="comment">/* handle all other events */</span> }</div>
<div class="line">);</div>
</div><!-- fragment --><p>Calling member functions is supported through lambda expressions. </p><div class="fragment"><div class="line"><span class="comment">// Provide a generic event handler</span></div>
<div class="line">window.handleEvents(</div>
<div class="line">    [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; event) { handle(event); }</div>
<div class="line">);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handlers</td><td>A variadic list of callables that take a specific event as their only parameter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#ab5975f6f6a06ecd6c18fa0f62cd1edf7" title="Wait for an event and return it.">waitEvent</a></code>, <code><a class="el" href="#a6090926b477e9d0a83854b94b9e1fd35" title="Pop the next event from the front of the FIFO event queue, if any, and return it.">pollEvent</a></code> </dd></dl>

</div>
</div>
<a id="ad87bd19e979c426cb819ccde8c95232e" name="ad87bd19e979c426cb819ccde8c95232e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad87bd19e979c426cb819ccde8c95232e">&#9670;&#160;</a></span>hasFocus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sf::WindowBase::hasFocus </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the window has the input focus. </p>
<p>At any given time, only one window may have the input focus to receive input events such as keystrokes or most mouse events.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if window has focus, <code>false</code> otherwise </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#a448770d2372d8df0a1ad6b1c7cce3c89" title="Request the current window to be made the active foreground window.">requestFocus</a></code> </dd></dl>

</div>
</div>
<a id="aa43559822564ef958dc664a90c57cba0" name="aa43559822564ef958dc664a90c57cba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43559822564ef958dc664a90c57cba0">&#9670;&#160;</a></span>isOpen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sf::WindowBase::isOpen </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell whether or not the window is open. </p>
<p>This function returns whether or not the window exists. Note that a hidden window (<code>setVisible(false)</code>) is open (therefore this function would return <code>true</code>).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the window is open, <code>false</code> if it has been closed </dd></dl>

</div>
</div>
<a id="a3397a7265f654be7ce9ccde3a53a39df" name="a3397a7265f654be7ce9ccde3a53a39df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3397a7265f654be7ce9ccde3a53a39df">&#9670;&#160;</a></span>onCreate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sf::WindowBase::onCreate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function called after the window has been created. </p>
<p>This function is called so that derived classes can perform their own specific initialization as soon as the window is created. </p>

<p>Reimplemented in <a class="el" href="classsf_1_1RenderWindow.html#aab231189dcb7d529d7d535772ac5ab01">sf::RenderWindow</a>.</p>

</div>
</div>
<a id="a8be41815cbeb89bc49e8752b62283192" name="a8be41815cbeb89bc49e8752b62283192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be41815cbeb89bc49e8752b62283192">&#9670;&#160;</a></span>onResize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sf::WindowBase::onResize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function called after the window has been resized. </p>
<p>This function is called so that derived classes can perform custom actions when the size of the window changes. </p>

<p>Reimplemented in <a class="el" href="classsf_1_1RenderWindow.html#a5223392a3ebd6581bd7b2c5e211ba072">sf::RenderWindow</a>.</p>

</div>
</div>
<a id="afada06381eb41e6a0b027133ef875740" name="afada06381eb41e6a0b027133ef875740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afada06381eb41e6a0b027133ef875740">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1WindowBase.html">WindowBase</a> &amp; sf::WindowBase::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1WindowBase.html">WindowBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy assignment. </p>

</div>
</div>
<a id="a58f9f0faf72adf9b53638061bae4d8b2" name="a58f9f0faf72adf9b53638061bae4d8b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58f9f0faf72adf9b53638061bae4d8b2">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1WindowBase.html">WindowBase</a> &amp; sf::WindowBase::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1WindowBase.html">WindowBase</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment. </p>

</div>
</div>
<a id="a6090926b477e9d0a83854b94b9e1fd35" name="a6090926b477e9d0a83854b94b9e1fd35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6090926b477e9d0a83854b94b9e1fd35">&#9670;&#160;</a></span>pollEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classsf_1_1Event.html">Event</a> &gt; sf::WindowBase::pollEvent </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop the next event from the front of the FIFO event queue, if any, and return it. </p>
<p>This function is not blocking: if there's no pending event then it will return a <code>std::nullopt</code>. Note that more than one event may be present in the event queue, thus you should always call this function in a loop to make sure that you process every pending event. </p><div class="fragment"><div class="line"><span class="keywordflow">while</span> (<span class="keyword">const</span> std::optional event = window.pollEvent())</div>
<div class="line">{</div>
<div class="line">   <span class="comment">// process event...</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The event, otherwise <code>std::nullopt</code> if no events are pending</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#ab5975f6f6a06ecd6c18fa0f62cd1edf7" title="Wait for an event and return it.">waitEvent</a></code>, <code><a class="el" href="#ad86ae79ff4e2da25af1ca3cd06f79557" title="Handle all pending events.">handleEvents</a></code> </dd></dl>

</div>
</div>
<a id="a448770d2372d8df0a1ad6b1c7cce3c89" name="a448770d2372d8df0a1ad6b1c7cce3c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448770d2372d8df0a1ad6b1c7cce3c89">&#9670;&#160;</a></span>requestFocus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::WindowBase::requestFocus </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request the current window to be made the active foreground window. </p>
<p>At any given time, only one window may have the input focus to receive input events such as keystrokes or mouse events. If a window requests focus, it only hints to the operating system, that it would like to be focused. The operating system is free to deny the request. This is not to be confused with <code>setActive()</code>.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#ad87bd19e979c426cb819ccde8c95232e" title="Check whether the window has the input focus.">hasFocus</a></code> </dd></dl>

</div>
</div>
<a id="a07ab1f9f9dc2312ad0ee83d1ffee9715" name="a07ab1f9f9dc2312ad0ee83d1ffee9715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ab1f9f9dc2312ad0ee83d1ffee9715">&#9670;&#160;</a></span>setIcon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::WindowBase::setIcon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesf.html#adc674b5f5c13a6734954a18e01a73b42">Vector2u</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::uint8_t *</td>          <td class="paramname"><span class="paramname"><em>pixels</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the window's icon. </p>
<p><code>pixels</code> must be an array of <code>size</code> pixels in 32-bits RGBA format.</p>
<p>The OS default icon is used by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Icon's width and height, in pixels </td></tr>
    <tr><td class="paramname">pixels</td><td>Pointer to the array of pixels in memory. The pixels are copied, so you need not keep the source alive after calling this function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#accd36ae6244ae1e6d643f6c109e983f8" title="Change the title of the window.">setTitle</a></code> </dd></dl>

</div>
</div>
<a id="ad37f939b492c7ea046d4f7b45ac46df1" name="ad37f939b492c7ea046d4f7b45ac46df1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad37f939b492c7ea046d4f7b45ac46df1">&#9670;&#160;</a></span>setJoystickThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::WindowBase::setJoystickThreshold </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>threshold</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the joystick threshold. </p>
<p>The joystick threshold is the value below which no JoystickMoved event will be generated.</p>
<p>The threshold value is 0.1 by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>New threshold, in the range [0, 100] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd1199a64d459ba531deb65f093050a6" name="afd1199a64d459ba531deb65f093050a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd1199a64d459ba531deb65f093050a6">&#9670;&#160;</a></span>setKeyRepeatEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::WindowBase::setKeyRepeatEnabled </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>enabled</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable automatic key-repeat. </p>
<p>If key repeat is enabled, you will receive repeated KeyPressed events while keeping a key pressed. If it is disabled, you will only get a single event when the key is pressed.</p>
<p>Key repeat is enabled by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td><code>true</code> to enable, <code>false</code> to disable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65f856835295a85a2959c962a1616cad" name="a65f856835295a85a2959c962a1616cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65f856835295a85a2959c962a1616cad">&#9670;&#160;</a></span>setMaximumSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::WindowBase::setMaximumSize </td>
          <td>(</td>
          <td class="paramtype">const std::optional&lt; <a class="el" href="namespacesf.html#adc674b5f5c13a6734954a18e01a73b42">Vector2u</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>maximumSize</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum window rendering region size. </p>
<p>Pass <code>std::nullopt</code> to unset the maximum size</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maximumSize</td><td>New maximum size, in pixels </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a742a8f386668f58fe27c0b5f5929de7e" name="a742a8f386668f58fe27c0b5f5929de7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a742a8f386668f58fe27c0b5f5929de7e">&#9670;&#160;</a></span>setMinimumSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::WindowBase::setMinimumSize </td>
          <td>(</td>
          <td class="paramtype">const std::optional&lt; <a class="el" href="namespacesf.html#adc674b5f5c13a6734954a18e01a73b42">Vector2u</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>minimumSize</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the minimum window rendering region size. </p>
<p>Pass <code>std::nullopt</code> to unset the minimum size</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minimumSize</td><td>New minimum size, in pixels </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07487a3c7e04472b19e96d3a602213ec" name="a07487a3c7e04472b19e96d3a602213ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07487a3c7e04472b19e96d3a602213ec">&#9670;&#160;</a></span>setMouseCursor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::WindowBase::setMouseCursor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Cursor.html">Cursor</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cursor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the displayed cursor to a native system cursor. </p>
<p>Upon window creation, the arrow cursor is used by default.</p>
<dl class="section warning"><dt>Warning</dt><dd>The cursor must not be destroyed while in use by the window.</dd>
<dd>
Features related to <a class="el" href="classsf_1_1Cursor.html" title="Cursor defines the appearance of a system cursor.">Cursor</a> are not supported on iOS and Android.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Native system cursor type to display</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classsf_1_1Cursor.html#a3385d2f53bc5b3b296f0409f79a57116" title="Create a native system cursor.">sf::Cursor::createFromSystem</a></code>, <code><a class="el" href="classsf_1_1Cursor.html#a93aa2dfcc8c4f27513c6632153521fa7" title="Create a cursor with the provided image.">sf::Cursor::createFromPixels</a></code> </dd></dl>

</div>
</div>
<a id="a0023344922a1e854175c8ca22b072020" name="a0023344922a1e854175c8ca22b072020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0023344922a1e854175c8ca22b072020">&#9670;&#160;</a></span>setMouseCursorGrabbed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::WindowBase::setMouseCursorGrabbed </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>grabbed</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Grab or release the mouse cursor. </p>
<p>If set, grabs the mouse cursor inside this window's client area so it may no longer be moved outside its bounds. Note that grabbing is only active while the window has focus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grabbed</td><td><code>true</code> to enable, <code>false</code> to disable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa4a3372b2870294d1579d8621fe3c1a" name="afa4a3372b2870294d1579d8621fe3c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa4a3372b2870294d1579d8621fe3c1a">&#9670;&#160;</a></span>setMouseCursorVisible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::WindowBase::setMouseCursorVisible </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>visible</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Show or hide the mouse cursor. </p>
<p>The mouse cursor is visible by default.</p>
<dl class="section warning"><dt>Warning</dt><dd>On Windows, this function needs to be called from the thread that created the window.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visible</td><td><code>true</code> to show the mouse cursor, <code>false</code> to hide it </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7282bbf43820f20f41c704c2ab5b86f8" name="a7282bbf43820f20f41c704c2ab5b86f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7282bbf43820f20f41c704c2ab5b86f8">&#9670;&#160;</a></span>setPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::WindowBase::setPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesf.html#af0ffe1b157a56931ee3a9a1a771a827a">Vector2i</a></td>          <td class="paramname"><span class="paramname"><em>position</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the position of the window on screen. </p>
<p>This function only works for top-level windows (i.e. it will be ignored for windows created from the handle of a child window/control).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>New position, in pixels</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#a5ddaa5943f547645079f081422e45c81" title="Get the position of the window.">getPosition</a></code> </dd></dl>

</div>
</div>
<a id="abd2581f59f35bd379307ea5b6254631c" name="abd2581f59f35bd379307ea5b6254631c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd2581f59f35bd379307ea5b6254631c">&#9670;&#160;</a></span>setSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::WindowBase::setSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesf.html#adc674b5f5c13a6734954a18e01a73b42">Vector2u</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the size of the rendering region of the window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>New size, in pixels</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#a188a482d916a972d59d6b0700132e379" title="Get the size of the rendering region of the window.">getSize</a></code> </dd></dl>

</div>
</div>
<a id="accd36ae6244ae1e6d643f6c109e983f8" name="accd36ae6244ae1e6d643f6c109e983f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd36ae6244ae1e6d643f6c109e983f8">&#9670;&#160;</a></span>setTitle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::WindowBase::setTitle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1String.html">String</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>title</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the title of the window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">title</td><td>New title</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#a07ab1f9f9dc2312ad0ee83d1ffee9715" title="Change the window&#39;s icon.">setIcon</a></code> </dd></dl>

</div>
</div>
<a id="a576488ad202cb2cd4359af94eaba4dd8" name="a576488ad202cb2cd4359af94eaba4dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576488ad202cb2cd4359af94eaba4dd8">&#9670;&#160;</a></span>setVisible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::WindowBase::setVisible </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>visible</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Show or hide the window. </p>
<p>The window is shown by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visible</td><td><code>true</code> to show the window, <code>false</code> to hide it </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5975f6f6a06ecd6c18fa0f62cd1edf7" name="ab5975f6f6a06ecd6c18fa0f62cd1edf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5975f6f6a06ecd6c18fa0f62cd1edf7">&#9670;&#160;</a></span>waitEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classsf_1_1Event.html">Event</a> &gt; sf::WindowBase::waitEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1Time.html">Time</a></td>          <td class="paramname"><span class="paramname"><em>timeout</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classsf_1_1Time.html#a8db127b632fa8da21550e7282af11fa0">Time::Zero</a></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for an event and return it. </p>
<p>This function is blocking: if there's no pending event then it will wait until an event is received or until the provided timeout elapses. Only if an error or a timeout occurs the returned event will be <code>std::nullopt</code>. This function is typically used when you have a thread that is dedicated to events handling: you want to make this thread sleep as long as no new event is received. </p><div class="fragment"><div class="line"><span class="keywordflow">while</span> (<span class="keyword">const</span> std::optional event = window.waitEvent())</div>
<div class="line">{</div>
<div class="line">   <span class="comment">// process event...</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Maximum time to wait (<code><a class="el" href="classsf_1_1Time.html#a8db127b632fa8da21550e7282af11fa0" title="Predefined &quot;zero&quot; time value.">Time::Zero</a></code> for infinite)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The event, otherwise <code>std::nullopt</code> on timeout or if window was closed</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#a6090926b477e9d0a83854b94b9e1fd35" title="Pop the next event from the front of the FIFO event queue, if any, and return it.">pollEvent</a></code>, <code><a class="el" href="#ad86ae79ff4e2da25af1ca3cd06f79557" title="Handle all pending events.">handleEvents</a></code> </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a553f958a25683445088050a69d3de8e9" name="a553f958a25683445088050a69d3de8e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a553f958a25683445088050a69d3de8e9">&#9670;&#160;</a></span>Window</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classsf_1_1Window.html">Window</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="WindowBase_8hpp_source.html#l00586">586</a> of file <a class="el" href="WindowBase_8hpp_source.html">WindowBase.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="WindowBase_8hpp_source.html">WindowBase.hpp</a></li>
</ul>
</div><!-- contents -->
        </div>
        <div id="footer-container">
            <div id="footer">
                SFML is licensed under the terms and conditions of the <a href="https://www.sfml-dev.org/license.php">zlib/png license</a>.<br />
                Copyright &copy; Laurent Gomila &nbsp;::&nbsp;
                Documentation generated by <a href="http://www.doxygen.org/" title="doxygen website">doxygen</a> &nbsp;::&nbsp;
            </div>
        </div>
    </body>
</html>
